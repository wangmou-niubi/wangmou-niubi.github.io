{"meta":{"title":"犯罪嫌疑人王某","subtitle":"","description":"喵喵喵~~","author":"王馨","url":"https://wangmou-niubi.github.io","root":"/"},"pages":[],"posts":[{"title":"PFM2","slug":"PFM2","date":"2022-01-16T08:57:28.000Z","updated":"2022-01-16T11:23:09.705Z","comments":true,"path":"2022/01/16/PFM2/","link":"","permalink":"https://wangmou-niubi.github.io/2022/01/16/PFM2/","excerpt":"","text":"一、基本工具采用宝塔面板+Xshell7+阿里云服务器实现。 二、部署vue+SpringBoot1.阿里云服务器使用的是阿里轻量服务器 120.79.154.158 CenetOS7.6（Linux） 账号root 密钥PFM2（本地密钥指纹） 2.Xshell71.在轻量服务器开启本地密钥指纹后开放端口 2.新建会话 名称随便起，主机就是120.79.154.158 使用本地密钥登陆（无需输入密码） 安装宝塔面板（已安装则跳过，没安装则安装） 使用 SSH 连接工具，如堡塔SSH终端连接到您的 Linux 服务器后，挂载磁盘，根据系统执行相应命令开始安装（大约2分钟完成面板安装）： Centos安装脚本 1yum install -y wget &amp;&amp; wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_6.0.sh &amp;&amp; sh install.sh Ubuntu/Deepin安装脚本 1wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh Debian安装脚本 1wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install-ubuntu_6.0.sh &amp;&amp; bash install.sh Fedora安装脚本 1wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_6.0.sh &amp;&amp; bash install.sh 注意：必须为没装过其它环境如Apache/Nginx/php/MySQL的新系统,推荐使用centos 7.X的系统安装宝塔面板 或者[在线一键安装宝塔][https://www.bt.cn/download/linux.html] 如果已安装，则输入 1bt default 直接查询内网外网地址，使用默认账号密码进入 已经绑定了手机(18223558130) 3.宝塔面板首页 软件商店下载内容 创建数据库并把sql文件上传 进入宝塔面板后，点击数据库 添加数据库 填写对应的字段点击提交 然后导入sql文件 上传vue的打包文件和springboot的打包文件 点击文件 上传 把打包的文件上传到自己指定的位置，都可以 部署vue一定要安装Nginx，安装完成会自动部署80端口 点击网站 添加站点 填写域名（没有域名先填写ip） 根目录选择上传的dist文件 点击确定，访问ip或者域名，前端可正常显示 部署springboot 点击应用商店 Java项目一键部署（没有可以先安装） springboot 添加项目 填写信息 然后访问ip或者域名即可。 其他操作1.忘记密码https://www.bt.cn/bbs/thread-1172-1-1.html 或者手机验证，随你 2.需要使用password登录先用public key 的方式连接上服务器后输入 1vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config 点击insert进入编辑模式，找到最下面的PasswordAuthentication，改为yes就行了。","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/队列基本操作","date":"2021-12-09T12:07:58.100Z","updated":"2021-12-01T13:30:06.000Z","comments":true,"path":"2021/12/09/PTA题目集/队列基本操作/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E9%98%9F%E5%88%97%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"7-5 队列基本操作 请实现一个MyQueue类，实现出队，入队，求队列长度. 实现入队函数 void push(int x); 实现出队函数 int pop(); 实现求队列长度函数 int size(); 输入格式:每个输入包含1个测试用例。每个测试用例第一行给出一个正整数 n (n &lt;= 10^6) ，接下去n行每行一个数字，表示一种操作： 1 x ： 表示从队尾插入x，0&lt;=x&lt;=2^31-1。 2 ： 表示队首元素出队。 3 ： 表示求队列长度。 输出格式:对于操作2,若队列为空，则输出 “Invalid”,否则请输出队首元素。 对于操作3，请输出队列长度。 每个输出项最后换行。 输入样例:1234565321 10032结尾无空行 输出样例:12340Invalid1100 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.ArrayList;import java.util.Scanner;import java.util.Stack;public class Main &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int times = input.nextInt(); int in = 0; int control = 0; MyQueue myQueue = new MyQueue(); for (int i = 0; i &lt; times; i++) &#123; control = input.nextInt(); switch (control) &#123; case 1: in = input.nextInt(); myQueue.in(new Node(in)); break; case 2: Node get = myQueue.out(); if (get == null) &#123; System.out.println(&quot;Invalid&quot;); &#125; else System.out.println(get.content); break; case 3: System.out.println(myQueue.size); break; &#125; &#125; &#125;&#125;class MyQueue &#123; Node font; Node rear; public int size; MyQueue() &#123; this.size = 0; this.font = null; this.rear = null; &#125; public void in(Node item) &#123; if (this.font == null) &#123; this.font = item; this.rear = item; &#125; else &#123; this.rear.next = item; this.rear = item; &#125; size++; &#125; public Node out() &#123; if (this.font != null) &#123; Node get = this.font; this.font = this.font.next; size--; return get; &#125; else return null; &#125; public int size() &#123; return this.size; &#125;&#125;class Node &#123; public Node next; public int content; public Node(Node next, int content) &#123; this.next = next; this.content = content; &#125; public Node(int content) &#123; this.next = null; this.content = content; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/递增有序顺序表的插入","date":"2021-12-09T12:07:58.090Z","updated":"2021-12-01T13:24:18.000Z","comments":true,"path":"2021/12/09/PTA题目集/递增有序顺序表的插入/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E9%80%92%E5%A2%9E%E6%9C%89%E5%BA%8F%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5/","excerpt":"","text":"7-3 递增有序顺序表的插入 实验目的：1、掌握线性表的基本知识 2、深入理解、掌握并灵活运用线性表。3、熟练掌握线性表的存储结构及主要运算的实现 已知顺序表L递增有序，将X插入到线性表的适当位置上，保证线性表有序。。 输入格式:第1行输入顺序表长度，第2行输入递增有序的顺序表，第3行输入要插入的数据元素X。 输出格式:对每一组输入，在一行中输出插入X后的递增的顺序表。 输入样例:在这里给出一组输入。例如： 12351 3 5 7 96结尾无空行 输出样例:在这里给出相应的输出。例如： 123451,3,5,6,7,9,结尾无空行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.util.Scanner;public class Main &#123; static Scanner input = new Scanner(System.in); public static void main(String[] args) &#123; int num = input.nextInt(); Tab[] tabs = new Tab[num]; for(int i = 0 ; i &lt; num ;i++)&#123; tabs[i] = new Tab(input.nextInt()); &#125; Tab top = tabs[0]; Tab insert = new Tab(input.nextInt()); for(int i = 0 ; i &lt; num ;i++)&#123; if(i+1&lt;num)&#123; tabs[i].Next = tabs[i+1]; &#125; else tabs[i].Next = null; &#125; for(int i = 0 ; ;i++)&#123; if(tabs[i].num&gt;= insert.num)&#123; if(i&gt;0) &#123; tabs[i - 1].Next = insert; insert.Next = tabs[i]; break; &#125; else if(i==0)&#123; top = insert; top.Next = tabs[0]; break; &#125; &#125; if(i== tabs.length-1&amp;&amp; tabs[i].num&lt;= insert.num)&#123; tabs[i].Next =insert; insert.Next = null; break; &#125; &#125; for(int i = 0 ;;i++)&#123; System.out.print(top.num + &quot;,&quot;); if(top.Next==null)&#123; break; &#125; top = top.Next; &#125; &#125;&#125;class Tab&#123; public int num ; public Tab Next; public Tab(int num) &#123; this.num = num; &#125; public int getNum() &#123; return num; &#125; public void setNum(int num) &#123; this.num = num; &#125; public Tab getNext() &#123; return Next; &#125; public void setNext(Tab next) &#123; Next = next; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/计算表达式","date":"2021-12-09T12:07:58.080Z","updated":"2021-12-01T13:29:10.000Z","comments":true,"path":"2021/12/09/PTA题目集/计算表达式/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E8%AE%A1%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"7-4 计算表达式 给定一个中缀表达式，请编写程序计算该表达式的值。表达式包含+、-、*、\\、(、)，所有运算均为二元运算，操作数均为正整数，但可能不止一位，不超过5位。 运算结果为整数。 除法运算结果若为小数则进行截尾取整。若除法运算中除数为0，则输出ILLEGAL。 输入格式:输入为一个字符串，表示中缀表达式。 输出格式:输出为一个整数，为表达式的值；或者为一个字符串ILLEGAL。 输入样例:123455+(10*2)-6结尾无空行 输出样例:1234519结尾无空行 输入样例:123458*(999+1)结尾无空行 输出样例:123458000结尾无空行 输入样例:123451+5&#x2F;(1-1)结尾无空行 输出样例:12345ILLEGAL结尾无空行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.*;public class Main &#123; static Scanner in = new Scanner(System.in); static StringBuilder stringBuilder = new StringBuilder(); public static void main(String[] args) &#123; stringBuilder.append(in.nextLine()); System.out.println(cu(stringBuilder)); &#125; public static String cu(StringBuilder stringBuilder) &#123; ArrayList&lt;String&gt; num = new ArrayList&lt;&gt;(); ArrayList&lt;Character&gt; suan = new ArrayList&lt;&gt;(); int numArray = 0; num.add(&quot;&quot;); label: for (int k = 0; ; k++) &#123; if (k &lt;= stringBuilder.length() - 1) &#123; for (; ; ) &#123; if (k &lt;= stringBuilder.length() - 1) &#123; if (stringBuilder.charAt(k) &gt;= &#x27;0&#x27; &amp;&amp; stringBuilder.charAt(k) &lt;= &#x27;9&#x27;) &#123; num.set(numArray, num.get(numArray) + stringBuilder.charAt(k)); k++; &#125; else &#123; num.add(&quot;&quot;); break; &#125; &#125; else break label; &#125; if (stringBuilder.charAt(k) == &#x27;(&#x27; || stringBuilder.charAt(k) == &#x27;)&#x27;) &#123; int j = stringBuilder.indexOf(&quot;(&quot;); StringBuilder stringBuilder1 = new StringBuilder(stringBuilder.substring(j + 1, stringBuilder.lastIndexOf(&quot;)&quot;))); stringBuilder.delete(j + 1, stringBuilder.lastIndexOf(&quot;)&quot;)); stringBuilder.delete(j, j + 2); stringBuilder.insert(j, cu(stringBuilder1)); k--; &#125; else if (stringBuilder.charAt(k) == &#x27;+&#x27; || stringBuilder.charAt(k) == &#x27;-&#x27; || stringBuilder.charAt(k) == &#x27;*&#x27; || stringBuilder.charAt(k) == &#x27;/&#x27;) &#123; suan.add(stringBuilder.charAt(k)); numArray++; &#125; &#125; else break; &#125; for (; ; ) &#123; if (suan.contains(&#x27;*&#x27;)) &#123; int index = suan.indexOf(&#x27;*&#x27;); int re = Integer.parseInt(num.get(index)) * Integer.parseInt(num.get(index + 1)); num.remove(index); num.remove(index); num.add(index, String.valueOf(re)); suan.remove(index); &#125; else if (suan.contains(&#x27;/&#x27;)) &#123; int index = suan.indexOf(&#x27;/&#x27;); if (Integer.parseInt(num.get(index + 1)) == 0) &#123; System.out.println(&quot;ILLEGAL&quot;); System.exit(0); &#125; int re = Integer.parseInt(num.get(index)) / Integer.parseInt(num.get(index + 1)); num.remove(index); num.remove(index); num.add(index, String.valueOf(re)); suan.remove(index); &#125; else &#123; break; &#125; &#125; int sum = 0; sum = Integer.parseInt(num.get(0)); for (int i = 0; i &lt; suan.size(); i++) &#123; switch (suan.get(i)) &#123; case &#x27;+&#x27; : sum += Integer.parseInt(num.get(i + 1));break; case &#x27;-&#x27; : sum -= Integer.parseInt(num.get(i + 1));break; &#125; &#125; return String.valueOf(sum); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/胡同","date":"2021-12-09T12:07:58.070Z","updated":"2021-12-01T13:27:44.000Z","comments":true,"path":"2021/12/09/PTA题目集/胡同/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E8%83%A1%E5%90%8C/","excerpt":"","text":"7-2 胡同 有一个死胡同，宽度刚好只能让一辆汽车通过，偏偏老有汽车开到死胡同来，这下麻烦了，最先开来的汽车要最后才能倒退出去。给定一个汽车开来的序列和一个可能的倒车出去的序列，请判断汽车能否都倒退出去，若能则输出Yes，否则输出No。 输入格式:首先输入一个整数T，表示测试数据的组数，然后是T组测试数据。每组测试数据首先输入一个正整数n（n≤10），代表开来的汽车数，然后输入2n个整数，其中，前n个整数表示汽车开来的序列，后n个整数表示汽车可能倒出的序列。 输出格式:对于每组测试，判断能否倒车出该死胡同，若能则输出“Yes”，否则输出“No”。引号不必输出。 输入样例:12324 1 2 3 4 2 1 4 34 1 2 3 4 4 2 1 3 输出样例:12YesNo 提示:样例1的可能方案为：1进，2进，2出，1出，3进，4进，4出，3出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.*;public class Main &#123; static Scanner input = new Scanner(System.in); static int count = 0; static int numOfText = input.nextInt(); static int[] numOfCar = new int[numOfText]; static int[][] situIn = new int[numOfText][]; static int[][] situOut = new int[numOfText][]; public static void main(String[] args) &#123; for (int i = 0; i &lt; numOfText; i++) &#123; numOfCar[i] = input.nextInt(); situIn[i] = new int[numOfCar[i]]; situOut[i] = new int[numOfCar[i]]; for (int j = 0; j &lt; numOfCar[i]; j++) &#123; situIn[i][j] = input.nextInt(); &#125; for (int j = 0; j &lt; numOfCar[i]; j++) &#123; situOut[i][j] = input.nextInt(); &#125; &#125; for (int i = 0; i &lt; numOfText; i++) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; numOfCar[i]; j++) &#123; arrayList.add(situIn[i][j]); for (; ; ) &#123; if (arrayList.get(arrayList.size() - 1) == situOut[i][count]) &#123; count++; arrayList.remove(arrayList.size() - 1); &#125; if (arrayList.size() == 0 || arrayList.get(arrayList.size() - 1) != situOut[i][count]) &#123; break; &#125; &#125; &#125; if (count == numOfCar[i]) &#123; System.out.println(&quot;Yes&quot;); &#125; else &#123; System.out.println(&quot;No&quot;); &#125; count = 0; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/编程求x^y 最后三位数表示的整数","date":"2021-12-09T12:07:58.060Z","updated":"2021-12-01T13:21:02.000Z","comments":true,"path":"2021/12/09/PTA题目集/编程求x^y 最后三位数表示的整数/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E7%BC%96%E7%A8%8B%E6%B1%82x^y%20%E6%9C%80%E5%90%8E%E4%B8%89%E4%BD%8D%E6%95%B0%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%95%B4%E6%95%B0/","excerpt":"","text":"7-3 编程求x^y 最后三位数表示的整数 编程求x ^y 最后三位数表示的整数。 输入格式:输入不超过最大整数的两个数x、y 输出格式:输出x^y最后三位数 输入样例:123452 3结尾无空行 输出样例:18 12345678910111213141516171819import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; int pow; int base; Scanner input = new Scanner(System.in); base = input.nextInt(); pow = input.nextInt(); long result = 1; while (pow &gt; 0) &#123; if ((pow &amp; 1)==1) &#123; //判断pow result = result * base % 1000; &#125; pow &gt;&gt;= 1;//将幂减半 base = (base * base) % 1000;//底数变为平方倍 &#125; System.out.print(result); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/相同的树","date":"2021-12-09T12:07:58.050Z","updated":"2021-12-01T13:35:32.000Z","comments":true,"path":"2021/12/09/PTA题目集/相同的树/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/","excerpt":"","text":"6-1 相同的树 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 两棵树上的节点数目都在范围 [0, 100] 内 -−104 &lt;= Node.val &lt;= 104 函数接口定义：12在这里描述函数接口。例如：public static boolean isSameTree(TreeNode p, TreeNode q) 裁判测试程序样例：123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */ public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String str1 = sc.nextLine(); String str2 = sc.nextLine(); Tree tree1 = new Tree(str1); Tree tree2 = new Tree(str2); System.out.println(isSameTree(tree1.root, tree2.root)); &#125;/* 请在这里填写答案 */ 输入样例1： 121 2 3 0 0 0 01 2 3 0 0 0 0 输出样例1：在这里给出相应的输出。例如： 1true 输入样例2： 121 2 0 0 01 0 2 0 0 输出样例2：在这里给出相应的输出。例如： 1false 输入样例3： 121 2 1 0 0 0 01 1 2 0 0 0 0 输出样例3：在这里给出相应的输出。例如： 1false 12345678910111213141516171819public static boolean isSameTree(TreeNode p, TreeNode q)&#123; boolean isSame = true; if(p.val==q.val)&#123; if(p.left!=null&amp;&amp;q.left!=null) isSame &amp;= isSameTree(p.left,q.left); else if(p.right!=null&amp;&amp;q.right!=null)&#123; isSame &amp;= isSameTree(p.right,q.right); &#125; else if((p.left!=null&amp;&amp;q.left==null)||(q.left!=null&amp;&amp;p.left==null))&#123; return false; &#125; else if((p.right!=null&amp;&amp;q.right==null)||(q.right!=null&amp;&amp;p.right==null))&#123; return false; &#125; &#125; else return false; return isSame;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/相同数字的最大连续子序列","date":"2021-12-09T12:07:58.050Z","updated":"2021-12-01T13:19:58.000Z","comments":true,"path":"2021/12/09/PTA题目集/相同数字的最大连续子序列/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E7%9B%B8%E5%90%8C%E6%95%B0%E5%AD%97%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"7-2 相同数字的最大连续子序列 找出相同数字的最长连续子序列。 输入格式:输入一个以0结束的整数序列。 输出格式:输出序列中相同数字组成的最长连续子序列的长度。 输入样例:在这里给出一组输入。例如： 123452 4 4 8 8 8 8 2 4 4 0结尾无空行 输出样例:在这里给出相应的输出。例如： 14 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;int main()&#123; long count = 1 ; long now = 0; long num[1000000]; for(int i = 0 ; ; i++)&#123; scanf(&quot;%ld&quot;,&amp;num[i]); if(i&gt;0)&#123; if(num[i]==num[i-1])&#123; now++; &#125; else&#123; if(now+1 &gt; count)&#123; count = now+1; &#125; now = 0; &#125; if(num[i]==0)&#123; break; &#125; &#125; &#125; printf(&quot;%d&quot;,count); return 0;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/特殊的圣诞树","date":"2021-12-09T12:07:58.040Z","updated":"2021-12-01T13:37:26.000Z","comments":true,"path":"2021/12/09/PTA题目集/特殊的圣诞树/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E7%89%B9%E6%AE%8A%E7%9A%84%E5%9C%A3%E8%AF%9E%E6%A0%91/","excerpt":"","text":"7-3 特殊的圣诞树 圣诞节快到了，每个人都在建造圣诞树，你也不例外。然而，你是特别的，你想建立一棵特别的。你决定建立一个二叉树的圣诞树，并把它的根悬挂在天花板上。对于一颗二叉树，最上面的节点称为根节点，树中的每个节点都可能有0、1或2个子节点，没有子节点的节点称为叶子。除了根节点没有父节点之外，每个节点都有且只有一个父节点。你买了一个装饰包，里面装了一些装饰品，你想用它们来装饰树上所有的叶子，由于被你房间的高度限制，所以树不能比你的房屋高。树的高度是从根到最远叶子的路径上的边数。请注意，每个叶子必须由一个装饰品装饰(每个装饰品可以装饰1个叶子)，你必须使用所有的装饰品装饰完你的圣诞树，你需要设计一颗特别的圣诞树，即高度和叶子数受限制的且要尽可能多节点的二叉树，你能找到最特别的树吗？ 输入格式:您的程序将在一个或多个测试用例上进行测试。输入的第一行将是单个整数T (1 ≤ T ≤ 10,000)，表示测试用例的数量。接下来是T组测试用例。每个测试用例将包括一行由空格分隔的2个整数H和L (0≤H ≤1,000,000,000,1 ≤ L ≤ 1,000,000,000且1 ≤ L ≤ 2^H) ,分别代表最大可能的高度和树叶的数量。 输出格式:对于每个测试用例，打印一个包含Case n: ans的单行(其中n是测试用例的编号,ans是最特殊的圣诞树的节点数)，具体看样例。 输入样例:12323 23 3结尾无空行 输出样例:在这里给出相应的输出。例如： 12Case 1: 7Case 2: 9结尾无空行 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int T = input.nextInt(); int[] H = new int[T]; int[] L = new int[T]; for (int i = 0; i &lt; T; i++) &#123; H[i] = input.nextInt(); L[i] = input.nextInt(); &#125; for (int i = 0; i &lt; T; i++) &#123; int ans = 1; int n2 = L[i] - 1; int now = 1; if (H[i] == 0) &#123; System.out.println(&quot;Case &quot; + i + 1 + &quot;: &quot; + ans); break; &#125; for (int j = 0; j &lt; H[i]; j++) &#123; if(n2==0)&#123; ans+=(H[i]-now+1)*L[i]; break; &#125; for (int k = 0; k &lt; Math.pow(2, now - 1); k++) &#123; if (n2 == 0) &#123; ans+=1; continue; &#125; ans+=2; n2--; &#125; now++; &#125; System.out.println(&quot;Case &quot; + (i + 1) + &quot;: &quot; + ans); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/求根结点到x结点的路径","date":"2021-12-09T12:07:58.030Z","updated":"2021-12-01T13:36:14.000Z","comments":true,"path":"2021/12/09/PTA题目集/求根结点到x结点的路径/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E6%B1%82%E6%A0%B9%E7%BB%93%E7%82%B9%E5%88%B0x%E7%BB%93%E7%82%B9%E7%9A%84%E8%B7%AF%E5%BE%84/","excerpt":"","text":"7-1 求根结点到x结点的路径 求根结点到x结点的路径（假定结点不重复）。 输入样例：输入一行字符序列先序递归构建二叉树。每个字符对应一个结点，#表示空结点。第二行输入一个结点值x。 1252#3##41##6##3结尾无空行 输出样例：输出从根到结点x的路径。 15 2 3 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.util.Scanner;public class Main &#123; public static int num = 0; public static boolean isOk = false; public static String path = &quot;&quot;; public static void main(String[] args) &#123; TreeNode root = new TreeNode(); Scanner input = new Scanner(System.in); String[] str = (input.next()).split(&quot;&quot;); String val = input.next(); addTreeNode(str, root, val); printPath(root,val); &#125; public static void addTreeNode(String[] str, TreeNode root_2, String val) &#123; if (!str[num].equals(&quot;#&quot;)) &#123; root_2.val = str[num]; num++; &#125; else &#123; num++; return; &#125; root_2.left = new TreeNode(); root_2.right = new TreeNode(); addTreeNode(str, root_2.left, val); addTreeNode(str, root_2.right, val); &#125; public static void printPath(TreeNode root, String val) &#123; if (root != null) &#123; if(root.val!=null) &#123; root.path += (root.val + &quot; &quot;); &#125; if(root.left!=null) &#123; if(root.path!=null) &#123; root.left.path += root.path; &#125; &#125; if(root.right!=null) &#123; if(root.path!=null) &#123; root.right.path += root.path; &#125; &#125; if(root.val!=null) &#123; if (root.val.equals(val)) &#123; System.out.print(root.path); &#125; &#125; printPath(root.left, val); printPath(root.right, val); &#125; &#125;&#125;class Tree &#123; private TreeNode root;&#125;class TreeNode &#123; String val; TreeNode left; TreeNode right; String path = &quot;&quot;; TreeNode() &#123; &#125; TreeNode(String val) &#123; this.val = val; &#125; TreeNode(String val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/求A-B","date":"2021-12-09T12:07:58.020Z","updated":"2021-12-01T13:25:16.000Z","comments":true,"path":"2021/12/09/PTA题目集/求A-B/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E6%B1%82A-B/","excerpt":"","text":"7-4 求A-B 给定两个按元素值递增的有序顺序表A和B，集合的元素为30000以内的正整数，编写程序求A-B。 输入格式:第一行输入两个表的表长 第二行输入第一个顺序表元素 第三行输入第二个顺序表元素 输出格式:输出顺序表A中不在顺序表B中的元素个数。 输入样例:1235 51 2 3 4 53 4 5 6 7结尾无空行 输出样例:123452结尾无空行 123456789101112131415161718192021222324252627282930313233import java.util.Scanner;public class Main &#123; static Scanner input = new Scanner(System.in); public static void main(String[] args) &#123; int len_1 = input.nextInt(); int len_2 = input.nextInt(); int[] num1 = new int[len_1]; int[] num2 = new int[len_2]; int count = 0; for(int i = 0 ; i &lt; len_1 ; i++)&#123; num1[i] = input.nextInt(); &#125; for(int i = 0 ; i &lt; len_2 ; i++)&#123; num2[i] = input.nextInt(); &#125; for(int i = 0 ; i &lt; len_1 ; i++)&#123; for (int j = 0 ; j &lt; len_2 ;j++)&#123; if(num1[i]==num2[j])&#123; break; &#125; else if(j==len_2-1&amp;&amp;num1[i]!=num2[i])&#123; count++; &#125; &#125; &#125; System.out.println(count); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/旋转图像","date":"2021-12-09T12:07:58.010Z","updated":"2021-12-01T13:31:54.000Z","comments":true,"path":"2021/12/09/PTA题目集/旋转图像/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/","excerpt":"","text":"6-1 旋转图像 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 matrix.length == n matrix[i].length == n 1 &lt;= n &lt;= 20 -1000 &lt;= matrix[i][j] &lt;= 1000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/rotate-image 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 函数接口定义：1public void rotate(int[][] matrix) 裁判测试程序样例：1234567891011121314151617181920212223public static void printMatrix(int[][] matrix)&#123; for(int i = 0; i &lt; matrix.length; i++)&#123; for(int j = 0 ; j &lt; matrix[i].length; j++) System.out.print(matrix[i][j] + &quot; &quot;); System.out.println(); &#125;public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[][] matrix = new int[n][n]; for(int i = 0; i&lt; n; i++)&#123; for (int j = 0 ; j &lt; n; j++)&#123; matrix[i][j] = sc.nextInt(); &#125; &#125; rotate(matrix); printMatrix(matrix); &#125;/* 请在这里填写答案 */ 输入样例1： 先输入n，矩阵的长度，然后按行输入矩阵中的元素 123431 2 34 5 67 8 9结尾无空行 输出样例1：1237 4 1 8 5 2 9 6 3 输入样例2： 1234545 1 9 112 4 8 1013 3 6 715 14 12 16结尾无空行 输出样例2：123415 13 2 5 14 3 4 1 12 6 8 9 16 7 10 11 输入样例3：1211结尾无空行 输出样例3：11 输入样例4：在这里给出一组输入。例如： 12321 23 4结尾无空行 输出样例4：123 1 4 2 123456789101112131415 public static void rotate(int[][] matrix)&#123;if (matrix == null) &#123; return; &#125; int n = matrix.length; for (int i = 0; i &lt; n / 2; i++) &#123; for (int j = i; j &lt; n - 1 - i; j++) &#123; int temp = matrix[i][j]; matrix[i][j] = matrix[n-1-j][i]; matrix[n-1-j][i] = matrix[n-1-i][n-1-j]; matrix[n-1-i][n-1-j] = matrix[j][n-1-i]; matrix[j][n-1-i] = temp; &#125; &#125; &#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/括号匹配检验-简单版","date":"2021-12-09T12:07:58.000Z","updated":"2021-12-01T13:27:02.000Z","comments":true,"path":"2021/12/09/PTA题目集/括号匹配检验-简单版/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E6%A3%80%E9%AA%8C-%E7%AE%80%E5%8D%95%E7%89%88/","excerpt":"","text":"7-1 括号匹配检验-简单版 输入一行字符，其中包括任意合法的字符。要求编写程序，检验其中的括号 ( 和 ) 是否匹配。 输入格式:输入一行不超过1000个字符的字符串，以换行符结尾。 输出格式:输出括号匹配的检验结果，如果匹配，则输出 Yes!，否则输出 No!。 输入样例:12345(nb)(t(y&amp;f4)8)结尾无空行 输出样例:在这里给出相应的输出。例如： 12345Yes!结尾无空行 12345678910111213141516171819202122232425import java.text.Format;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); String in = input.nextLine(); ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); for(int i = 0 ; i &lt; in.length() ; i++)&#123; if(in.charAt(i)==&#x27;(&#x27;||in.charAt(i)==&#x27;)&#x27;)&#123; arrayList.add(String.valueOf(in.charAt(i))); &#125; if(arrayList.size()&gt;1&amp;&amp;((arrayList.get(arrayList.size()-1).equals(&quot;)&quot;))&amp;&amp;(arrayList.get(arrayList.size()-2).equals(&quot;(&quot;))))&#123; arrayList.remove(arrayList.size()-1); arrayList.remove(arrayList.size()-1); &#125; &#125; if(arrayList.size()==0)&#123; System.out.println(&quot;Yes!&quot;); &#125; else System.out.println(&quot;No!&quot;); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/打字问题","date":"2021-12-09T12:07:57.990Z","updated":"2021-12-01T13:25:52.000Z","comments":true,"path":"2021/12/09/PTA题目集/打字问题/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E6%89%93%E5%AD%97%E9%97%AE%E9%A2%98/","excerpt":"","text":"7-5 打字问题 小明正使用Microsoft Word打一篇文档，文档只包含a-z的小写字母和空格，在打字过程中可能会一次或多次按下Home键、End键、←方向键、→方向键、Insert键、Backspace键。请编写程序，给定小明在键盘上按键的序列，输出小明屏幕上最终显示的文本。 提示：Home键会将当前光标移至文本开始位置，End键当前光标移至文本尾，←键和→键会使当前光标左移或右移一个位置（如果光标在文档头则无法左移，光标在文档尾则无法右移），Insert键会在插入和替换文本间切换（默认是插入状态），Backspace键会删除当前光标前的一个字符。 输入格式:输入为不超过50000个字符，表示小明的按键序列。包含a-z的小写字母、空格以及字符[、]、{、}、-、=。其中字符“[”表示Home键，“]”表示End键，“{”表示←键，“}”表示→键，“-”表示Insert键，“=”表示Backspace键。 输出格式:输出为在小明屏幕上最终显示的文本。最后一个字母后没有回车或换行。 输入样例1:12345jilin[i lofe&#123;&#123;-v-&#125; ] universiti&#x3D;y结尾无空行 输出样例1:12345i love jilin university结尾无空行 输入样例2:12345abcd[c-de结尾无空行 输出样例2:12345cdecd结尾无空行 输入样例3:12345[[]][][]happy&#x3D;birthday结尾无空行 输出样例3:12345happbirthday结尾无空行 输入样例4:12345efg[bbb&#125;&#125;&#x3D;&#125;&#125;&#125;&#125;&#x3D;[&#123;&#123;&#123;&#123;a结尾无空行 输出样例4:12345abbbe结尾无空行 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Scanner;public class Main &#123; static Scanner input = new Scanner(System.in); public static void main(String[] args) &#123; int model = 0; StringBuilder stringBuilder = new StringBuilder(); StringBuilder stringBuilder1 = new StringBuilder(); int nowIndex = 0; stringBuilder.append(input.nextLine()); for(int i = 0 ; i&lt; stringBuilder.length() ;i++)&#123; char c = stringBuilder.charAt(i); switch (c)&#123; case &#x27;[&#x27;: nowIndex = 0;break; case &#x27;]&#x27;: nowIndex = stringBuilder1.length();break; case &#x27;&#123;&#x27;: if (nowIndex&gt;0)nowIndex--;break; case &#x27;&#125;&#x27;: if(nowIndex+1&lt;=stringBuilder1.length())nowIndex++;break; case &#x27;-&#x27;: model++; break; case &#x27;=&#x27;: stringBuilder1.delete(nowIndex-1,nowIndex);nowIndex--; break; default: if(model%2==0)&#123; stringBuilder1.insert(nowIndex,c); nowIndex++; &#125; else &#123; stringBuilder1.replace(nowIndex,nowIndex+1,String.valueOf(c)); nowIndex++; &#125; &#125; &#125; System.out.println(stringBuilder1); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/带密码的约瑟夫问题","date":"2021-12-09T12:07:57.980Z","updated":"2021-12-01T13:22:28.000Z","comments":true,"path":"2021/12/09/PTA题目集/带密码的约瑟夫问题/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E5%B8%A6%E5%AF%86%E7%A0%81%E7%9A%84%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/","excerpt":"","text":"7-1 带密码的约瑟夫问题 带密码的约瑟夫问题：编号为1，2，……，n的n个人按照顺时针方向围坐一圈，每个人有自己的编号(正整数)、姓名和密码（正整数）三个数据项。一开始任选一个正整数作为报数上限值，从第一个人开始顺时针方向自1开始报数，报到m时停止报数。报m 的人出列，将他的密码作为新的m值，从他在顺时针方向的下一个人开始重新报数，如此下去，直到所有人全部出队为止。设计一个程序来求出出队顺序。 输入格式:输入人数 n（1≤n≤50），再逐行输入每个人的信息（各项之间用逗号隔开），然后输入报数上限值m。 输出格式:按出队顺序逐行输出每个人的信息，每人信息一行，数据项之间用逗号隔开 输入样例:在这里给出一组输入。例如： 123456751,刘三,32,李丽,53,吴勇,84,钱多,25,齐民,42 输出样例:在这里给出相应的输出。例如： 123452,李丽,53,吴勇,85,齐民,44,钱多,21,刘三,3结尾无空行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.Scanner;public class Main &#123; static Scanner input = new Scanner(System.in); static int n = Integer.parseInt(input.next()); static String[] personName = new String[n]; static int[][] person = new int[n][2]; static int m; static boolean[] isOut = new boolean[n]; static int[] num = new int[n]; public static void main(String[] args) &#123; for(int j = 0 ; j &lt; n ; j++) &#123; String get = input.next(); String[] spli = get.split(&quot;,&quot;); for (int i = 0; i &lt; spli.length; i++) &#123; if (i % 3 == 0) &#123; person[j][0] = Integer.parseInt(spli[i]); &#125; else if (i % 3 == 1) &#123; personName[j] = spli[i]; &#125; else &#123; person[j][1] = Integer.parseInt(spli[i]); break; &#125; &#125; &#125; m = input.nextInt(); search(0, m, n); &#125; public static void search(int start, int step, int num) &#123; if (num == 0) &#123; return; &#125; int numOfStep = 0; int now = start; for (; ; ) &#123; if (isOut[now % n]) &#123; now++; continue; &#125; else &#123; now++; numOfStep++; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!isOut[i]) &#123; break; &#125; &#125; if (numOfStep == step % num || ((step % num == 0) &amp;&amp; numOfStep == num)) &#123; int next = (now - 1) % n; System.out.println(person[next][0] + &quot;,&quot; + personName[next] + &quot;,&quot; + person[next][1]); isOut[next] = true; for (int i = next; i &lt; n; i++) &#123; if (!isOut[i % n]) &#123; now = i; break; &#125; &#125; search(now, person[next][1], num - 1); break; &#125; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/小明的第一个扑克牌“魔术”（队列或链表操作）","date":"2021-12-09T12:07:57.970Z","updated":"2021-12-01T13:23:38.000Z","comments":true,"path":"2021/12/09/PTA题目集/小明的第一个扑克牌“魔术”（队列或链表操作）/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E5%B0%8F%E6%98%8E%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%89%91%E5%85%8B%E7%89%8C%E2%80%9C%E9%AD%94%E6%9C%AF%E2%80%9D%EF%BC%88%E9%98%9F%E5%88%97%E6%88%96%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C%EF%BC%89/","excerpt":"","text":"小明的第一个扑克牌“魔术”（队列或链表操作） 小明刚上小学，学会了第一个扑克牌“魔术”，到处给人表演。魔术的内容是这样的： 他手里握着一叠扑克牌：A，2，….J，Q，K 一共13张。他先自己精心设计它们的顺序，然后正面朝下拿着，开始表演。 只见他先从最下面拿一张放到最上面，再从最下面拿一张翻开放桌子上，是A；然后再从最下面拿一张放到最上面，再从最下面拿一张翻开放桌子上，是2； ……如此循环直到手中只有一张牌，翻开放桌子上，刚好是K。 这时，桌上牌的顺序是：A,2,3,4,5,6,7,8,9,10,J,Q,K 请你计算一下，小明最开始的时候手里牌的顺序是怎样的。 把结果写出来，逗号分割，小明“魔术”开始时，最下面的那张牌输出为第一个数据。 输入格式:输入这叠扑克的数量。 输出格式:对每一组输入，在一行中输出牌的初始顺序（最下面的那张牌输出为第一个数据，数字1表示A，数字11表示J，数字12表示Q，数字13表示K）。 输入样例:在这里给出一组输入。例如： 123453结尾无空行 输出样例:在这里给出相应的输出。例如： 12,1,3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import java.util.Scanner;public class Main &#123; static Scanner input = new Scanner(System.in); public static void main(String[] args) &#123; int numOfCard = input.nextInt(); Tab temp ; int numPart =1; Tab[] tabs = new Tab[numOfCard]; int[] numPrint = new int[numOfCard]; for(int i = 0 ; i&lt; numOfCard ; i++)&#123; tabs[i] = new Tab(i); &#125; for(int i = 0 ; i&lt; numOfCard ; i++)&#123; if(i+1&lt;numOfCard) &#123; tabs[i].Next = tabs[i+1]; &#125; else tabs[i].Next = null; &#125; Tab isBottom = tabs[numOfCard-1]; Tab isTop = tabs[0]; for(int i = 0;;i++)&#123; if(isTop.Next!=null) &#123; if (i % 2 == 0) &#123; isBottom.Next = isTop; isBottom = isTop; temp = isTop.Next; isTop.Next = null; isTop = temp; &#125; else &#123; isTop.setOk(true); numPrint[isTop.num] = numPart; numPart++; isTop = isTop.Next; &#125; &#125; else &#123; numPrint[isTop.num] = numPart; break; &#125; &#125; for(int i = 0 ; i &lt; numOfCard ; i++)&#123; System.out.print(numPrint[i]); if(i+1&lt;numOfCard)&#123; System.out.print(&quot;,&quot;); &#125; &#125; &#125;&#125;class Tab &#123; public int num; public Tab Next; boolean isOk; public Tab(int num, Tab next, boolean isOk) &#123; this.num = num; Next = next; this.isOk = isOk; &#125; public Tab(int num)&#123; this.isOk = false; this.num = num; &#125; public int getNum() &#123; return num; &#125; public void setNum(int num) &#123; this.num = num; &#125; public Tab getNext() &#123; return Next; &#125; public void setNext(Tab next) &#123; Next = next; &#125; public boolean isOk() &#123; return isOk; &#125; public void setOk(boolean ok) &#123; isOk = ok; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/子串在母串中出现的次数","date":"2021-12-09T12:07:57.960Z","updated":"2021-12-01T13:34:08.000Z","comments":true,"path":"2021/12/09/PTA题目集/子串在母串中出现的次数/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E5%AD%90%E4%B8%B2%E5%9C%A8%E6%AF%8D%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/","excerpt":"","text":"7-3子串在母串中出现的次数 统计一个长度为3的字符串在另一个字符串中出现的次数。。 输入格式:在第一行输入长度小于20的长的字符串。在字符串中不要出现换行符，空格，制表符。 在第二行输入长度为3的字符串。在字符串中不要出现换行符，空格，制表符。 输出格式:直接输出结果，没有任何附加字符。 输入样例:12asdfgasdrfasasd结尾无空行 输出样例:123452结尾无空行 123456789101112131415161718192021222324252627import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); StringBuilder str = new StringBuilder(); String m; int num = 0 ; str.append(in.nextLine()); m = in.nextLine(); int i = 0; for (; ; ) &#123; if(str.indexOf(m,i)!=-1&amp;&amp;i!=-1) &#123; i = str.indexOf(m, i+3); num++; &#125; else &#123; System.out.println(num); break; &#125; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/字符串中最长重复子串","date":"2021-12-09T12:07:57.960Z","updated":"2021-12-01T13:33:20.000Z","comments":true,"path":"2021/12/09/PTA题目集/字符串中最长重复子串/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/","excerpt":"","text":"7-2 字符串中最长重复子串 输入一字符串，找出其中出现的相同且长度最长的子串，输出该子串的长度。规定字符串本身不能称为自己的子串。请编写效率尽可能高的程序完成这个棘手的任务。 输入格式:输入为一个字符串，表示报文，包含不超过10000个字母。 输出格式:输出为一个整数，表示破解出的密文串的长度。 输入样例1:12345xabceabcf结尾无空行 输出样例1:123453结尾无空行 输入样例2:12345xyabcabcayx结尾无空行 输出样例2:123454结尾无空行 123456789101112131415161718192021222324252627282930313233343536373839import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); StringBuilder str = new StringBuilder(); str.append(in.next()); String f; String b; int now = 1; for (int i = 0; ; i++) &#123; int num = 1; for (; ; ) &#123; try &#123; f = str.substring(i, i + num + 1); int judge = str.indexOf(f, i+1); if (judge != -1) &#123; num++; &#125; else &#123; if (now &lt; num) &#123; now = num; &#125; break; &#125; &#125; catch (Exception e1)&#123; break; &#125; &#125; if(i&gt;str.length())&#123; System.out.println(now); break; &#125; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/好中缀","date":"2021-12-09T12:07:57.950Z","updated":"2021-12-01T13:32:28.000Z","comments":true,"path":"2021/12/09/PTA题目集/好中缀/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E5%A5%BD%E4%B8%AD%E7%BC%80/","excerpt":"","text":"7-1 好中缀 我们称一个字符串S的子串T为好中缀，如果T是去除S中满足如下条件的两个子串p和q后剩余的字符串。 （1）p是S的前缀，q是S的后缀； （2）p=q； （3）p和q是满足条件(1)(2)的所有子串中的第二长者。 注意一个字符串不能称为自己的前缀或后缀。好中缀至少为空串，其长度大于等于0，不能为负数。 输入格式:输入为一个字符串S，包含不超过100000个字母。 输出格式:输出为一个整数，表示好中缀的长度。 输入样例1:12345abcabcxxxabcabc结尾无空行 输出样例1:123459结尾无空行 输入样例2:12345xacbacba结尾无空行 输出样例2:123458结尾无空行 输入样例3:12345aaa结尾无空行 输出样例3:123451结尾无空行 123456789101112131415161718192021222324252627282930313233import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); StringBuilder str = new StringBuilder(); str.append(in.next()); String f; String b; int[] result = &#123;0, 0&#125;; for (int i = 1; i &lt; str.length() / 2; i++) &#123; f = str.substring(0, i); b = str.substring(str.length() - i - 1, str.length() - 1); if (f.equals(b)) &#123; result[1] = result[0]; result[0] = str.length() - (i + 1) * 2; &#125; &#125; if (result[1] == 0) &#123; result[1] = result[0]; &#125; if (result[1] == 0 &amp;&amp; result[0] == 0) &#123; result[1] = str.length(); &#125; if (str.length() == 3 &amp;&amp; str.substring(0, 1).equals(str.substring(1, 2))) &#123; result[1] = 1; &#125; System.out.println(result[1]); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/列车车厢重排","date":"2021-12-09T12:07:57.940Z","updated":"2021-12-01T13:28:34.000Z","comments":true,"path":"2021/12/09/PTA题目集/列车车厢重排/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E5%88%97%E8%BD%A6%E8%BD%A6%E5%8E%A2%E9%87%8D%E6%8E%92/","excerpt":"","text":"7-3 列车车厢重排 火车站的列车调度铁轨的结构如下所示： (Exit) 9 8 7 6 5 4 3 2 1 &lt;== ………………………………… &lt;==== 8 4 2 5 3 9 1 6 7 (Entrance) 两端分别是一条入口（Entrance）轨道和一条出口（Exit）轨道，它们之间可能有N条平行的轨道。每趟列车从入口可以选择任意一条轨道进入排队，以方便最后有序从出口离开。在前例中有9趟列车，在入口处按照{8，4，2，5，3，9，1，6，7}的顺序排队等待进入。如果要求它们必须按序号递减的顺序从出口离开，则至少需要多少条平行铁轨用于调度？调度入队后，各个队列里车厢情况如何？ 输入格式： 输入第一行给出一个整数N (2 ≤ N ≤99 )，下一行给出从1到N的整数序号的一个重排列。数字间以空格分隔。 输出格式： 第一行输出1号车厢所在的队列中的元素（车厢编号间以空格分隔），注意，调度时，车厢只进入队列等待，并不出队。 在第二行中输出可以将输入的列车按序号递减的顺序重排所需要最少的辅助铁轨（队列）条数。 输入样例:1298 4 2 5 3 9 1 6 7结尾无空行 输出样例:128 4 2 14结尾无空行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.*;public class Main &#123; public static void main(String[] args) &#123; int count = 0; Scanner input = new Scanner(System.in); int num = input.nextInt(); int remove=0; ArrayList&lt;Integer&gt; end = new ArrayList&lt;&gt;(); ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayLists = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); for(int i = 0 ; i &lt; num ; i++)&#123; nums.add(input.nextInt()); &#125; label: for(int i = 0 ; i &lt; num ; i++)&#123; if(i==0)&#123; arrayLists.add(new ArrayList&lt;&gt;()); count++; arrayLists.get(0).add(nums.get(0)); end.add(nums.get(0)); &#125; if(i&gt;0)&#123; for(int j = 0 ; j &lt; end.size() ; j++)&#123; if(nums.get(i)&lt;end.get(j))&#123; end.set(j,nums.get(i)); if(j==0)&#123; arrayLists.get(0).add(nums.get(i)); &#125; continue label; &#125; &#125; count++; end.add(nums.get(i)); &#125; &#125; for(int i = 0 ; i &lt;arrayLists.get(0).size();i++)&#123; System.out.print(arrayLists.get(0).get(i)); if(i!=arrayLists.get(0).size()-1) &#123; System.out.print(&quot; &quot;); &#125; &#125; System.out.println(); System.out.println(count); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/先序序列创建二叉树，输出先序序列、中序序列、后序序列并输出叶子结点数","date":"2021-12-09T12:07:57.930Z","updated":"2021-12-01T13:36:52.000Z","comments":true,"path":"2021/12/09/PTA题目集/先序序列创建二叉树，输出先序序列、中序序列、后序序列并输出叶子结点数/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E5%85%88%E5%BA%8F%E5%BA%8F%E5%88%97%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E8%BE%93%E5%87%BA%E5%85%88%E5%BA%8F%E5%BA%8F%E5%88%97%E3%80%81%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97%E3%80%81%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97%E5%B9%B6%E8%BE%93%E5%87%BA%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E6%95%B0/","excerpt":"","text":"7-2 先序序列创建二叉树，输出先序序列、中序序列、后序序列并输出叶子结点数 对于给定的二叉树，输出其先序序列、中序序列、后序序列并输出叶子结点数。 输入格式:二叉树的先序遍历序列。 提示：一棵二叉树的先序序列是一个字符串，若字符是‘#’,表示该二叉树是空树，否则该字符是相应结点的数据元素。 输出格式:若是非空二叉树，则输出四行内容 第一行是二叉树的先序遍历序列； 第二行是二叉树的中序遍历序列； 第三行是二叉树的后序遍历序列； 第四行是叶子结点数； 若是空二叉树 只需输出叶子数0 输入样例1:12345FCA##DB###EHM###G##结尾无空行 输出样例1:1234FCADBEHMGACBDFMHEGABDCMHGEF4结尾无空行 输入样例2:12345#结尾无空行 输出样例2:123450结尾无空行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import java.util.Scanner;public class Main &#123; public static int num = 0; public static boolean isOk = false; public static int numOfLeaf = 0; public static String path = &quot;&quot;; public static void main(String[] args) &#123; TreeNode root = new TreeNode(); Scanner input = new Scanner(System.in); String[] str = (input.next()).split(&quot;&quot;); addTreeNode(str, root, &quot;156456&quot;, &quot;b&quot;); num=0; if(root.val!=null) System.out.println(); addTreeNode(str, root, &quot;156456&quot;, &quot;m&quot;); num=0; if(root.val!=null) System.out.println(); addTreeNode(str, root, &quot;156456&quot;, &quot;a&quot;); num=0; if(root.val!=null) System.out.println(); printPath(root,&quot;51651651&quot;); System.out.println(numOfLeaf); &#125; public static void addTreeNode(String[] str, TreeNode root_2, String val, String type) &#123; if (!str[num].equals(&quot;#&quot;)) &#123; root_2.val = str[num]; num++; &#125; else &#123; num++; return; &#125; root_2.left = new TreeNode(); root_2.right = new TreeNode(); if (type.equals(&quot;b&quot;)) &#123; if (!isOk) &#123; System.out.print(root_2.val); &#125; if (root_2.val.equals(val)) &#123; isOk = true; &#125; addTreeNode(str, root_2.left, val, type); addTreeNode(str, root_2.right, val, type); &#125; else if (type.equals(&quot;m&quot;)) &#123; addTreeNode(str, root_2.left, val, type); if (!isOk) &#123; System.out.print(root_2.val); &#125; if (root_2.val.equals(val)) &#123; isOk = true; &#125; addTreeNode(str, root_2.right, val, type); &#125; else if (type.equals(&quot;a&quot;)) &#123; addTreeNode(str, root_2.left, val, type); addTreeNode(str, root_2.right, val, type); if (!isOk) &#123; System.out.print(root_2.val); &#125; if (root_2.val.equals(val)) &#123; isOk = true; &#125; &#125; &#125; public static void printPath(TreeNode root, String val) &#123; if(root.val==null)&#123; return; &#125; else if(root.left.val==null&amp;&amp;root.right.val==null)&#123; numOfLeaf++; &#125; printPath(root.left, val); printPath(root.right, val); &#125; &#125;class Tree &#123; private TreeNode root;&#125;class TreeNode &#123; String val; TreeNode left = null; TreeNode right = null; String path = &quot;&quot;; TreeNode() &#123; &#125; TreeNode(String val) &#123; this.val = val; &#125; TreeNode(String val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/二叉树最深间隔最远结点","date":"2021-12-09T12:07:57.920Z","updated":"2021-12-01T13:38:18.000Z","comments":true,"path":"2021/12/09/PTA题目集/二叉树最深间隔最远结点/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E6%B7%B1%E9%97%B4%E9%9A%94%E6%9C%80%E8%BF%9C%E7%BB%93%E7%82%B9/","excerpt":"","text":"7-4 二叉树最深间隔最远结点 给定一棵非空二叉树，数据域值为不等于0的整数。请编写程序找出其最深层间隔最远的两个结点，输出这两个结点差的绝对值。如图1所示的各二叉树最深层间隔最远的结点为5和8。如果最深层只有一个结点，则输出0。 输入格式:输入为一组用空格间隔的整数，个数不超过200个，表示带空指针信息的二叉树先根序列，其中空指针信息用0表示。 输出格式:输出为一个整数，为二叉树最深层间隔最远的两个结点差的绝对值，如果最深层只有一个结点，则输出0。 输入样例1:123451 2 0 5 0 0 3 6 0 0 8 0 0结尾无空行 输出样例1:在这里给出相应的输出。例如： 123453结尾无空行 输入样例2:123451 2 0 5 0 0 3 0 0结尾无空行 输出样例2:在这里给出相应的输出。例如： 123450结尾无空行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import java.util.Scanner;public class Main &#123; public static int num = 0; public static boolean isOk = false; public static String path = &quot;&quot;; public static void main(String[] args) &#123; TreeNode root = new TreeNode(); Scanner input = new Scanner(System.in); String[] str = (input.nextLine()).split(&quot; &quot;); addTreeNode(str, root, &quot;val&quot;); Result rl = findL(root.left); Result rr = findL(root.right); if(rl.deep== rr.deep) &#123; System.out.print(Math.abs(Integer.parseInt(rl.Node.val) - Integer.parseInt(rr.Node.val))); &#125; else System.out.print(0); &#125; public static Result findL(TreeNode node) &#123; int deep = 0; int DL = 0; int DR = 0; Result rl = new Result(); Result rr = new Result(); deep++; if (node.left.val != null) &#123; rl = findL(node.left); DL += rl.deep; &#125; if (node.right.val != null) &#123; rr = findL(node.right); DR += rr.deep; &#125; if(node.left.val==null&amp;&amp;node.right.val==null)&#123; return new Result(node,deep); &#125; if(node.left.val==null)&#123; return new Result(rr.Node,DR+deep); &#125; if(node.right.val==null)&#123; return new Result(rl.Node,DL+deep); &#125; return new Result(DL&gt;DR? rl.Node : rr.Node,deep+Math.max(DL,DR)); &#125; public static void addTreeNode(String[] str, TreeNode root_2, String val) &#123; if (!str[num].equals(&quot;0&quot;)) &#123; root_2.val = str[num]; num++; &#125; else &#123; num++; return; &#125; root_2.left = new TreeNode(); root_2.right = new TreeNode(); addTreeNode(str, root_2.left, val); addTreeNode(str, root_2.right, val); &#125;&#125;class Result &#123; TreeNode Node; int deep=0; public Result()&#123; &#125; public Result( TreeNode node) &#123; this.Node = node; &#125; public Result(TreeNode node, int deep) &#123; this.Node = node; this.deep = deep; &#125;&#125;class TreeNode &#123; String val; TreeNode left; TreeNode right; String path = &quot;&quot;; TreeNode() &#123; &#125; TreeNode(String val) &#123; this.val = val; &#125; TreeNode(String val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/三数之和","date":"2021-12-09T12:07:57.910Z","updated":"2021-12-01T13:39:02.000Z","comments":true,"path":"2021/12/09/PTA题目集/三数之和/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"6-1 三数之和 (10 分) 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 0 &lt;= nums.length &lt;= 3000 −105 &lt;= nums[i] &lt;= 105 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/3sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 函数接口定义：1public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) 裁判测试程序样例：12345678910111213141516在这里给出函数被调用进行测试的例子。例如：public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] array = new int[n]; for(int i = 0; i &lt;n; i++) array[i] = sc.nextInt(); List&lt;List&lt;Integer&gt;&gt; result = threeSum(array); for(int i = 0; i &lt; result.size(); i++)&#123; List&lt;Integer&gt; list = result.get(i); for(int j = 0; j &lt; list.size(); j++) System.out.print(list.get(j) + &quot; &quot;); System.out.println(); &#125; &#125;/* 请在这里填写答案 */ 输入样例2：第一行输入数组长度n，第二行输入数组元素，以空格间隔 123450结尾无空行 输出样例2：每个三元组一行 1结尾无空行 输入样例3：第一行输入数组长度n，第二行输入数组元素，以空格间隔 1210结尾无空行 输出样例3：每个三元组一行 1结尾无空行 123456789101112131415161718192021222324252627282930313233public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length &amp;&amp; nums[i] &lt;= 0; i++) &#123; for (int j = nums.length - 1; j &gt; i; j--) &#123; for (int k = j - 1; k &gt; i; k--) &#123; if ((nums[k] + nums[i] + nums[j]) == 0) &#123; List&lt;Integer&gt; match = new ArrayList&lt;Integer&gt;(); match.add(0); match.add(0); match.add(0); match.set(0, nums[i]); match.set(1, nums[k]); match.set(2, nums[j]); result.add(match); &#125; &#125; &#125; &#125; for (int l = 0; l &lt; result.size(); l++) &#123; for (int i = l+1; i &lt; result.size() ; i++) &#123; if(result.get(l).equals(result.get(i)))&#123; result.remove(l); l=0; i=0; &#125; &#125; &#125; return result; &#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/三元组顺序表表示的稀疏矩阵加法","date":"2021-12-09T12:07:57.900Z","updated":"2021-12-01T13:34:40.000Z","comments":true,"path":"2021/12/09/PTA题目集/三元组顺序表表示的稀疏矩阵加法/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/%E4%B8%89%E5%85%83%E7%BB%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E8%A1%A8%E7%A4%BA%E7%9A%84%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E5%8A%A0%E6%B3%95/","excerpt":"","text":"7-4 三元组顺序表表示的稀疏矩阵加法 三元组顺序表表示的稀疏矩阵加法。 输入格式:输入第1行为两个同型矩阵的行数m、列数n，矩阵A的非零元素个数t1，矩阵B的非零元素个数t2。 按行优先顺序依次输入矩阵A三元组数据，共t1行，每行3个数，分别表示非零元素的行标、列标和值。 按行优先顺序依次输入矩阵B三元组数据，共t2行，每行3个数，分别表示非零元素的行标、列标和值。 输出格式:输出第1行为相加后矩阵行数m、列数n及非零元素个数t。 输出t行相加后的三元组顺序表结果，每行输出非零元素的行标、列标和值，每行数据之间用空格分隔。 输入样例1:123456784 4 3 40 1 -51 3 12 2 10 1 31 3 -13 0 53 3 7结尾无空行 输出样例1:123454 4 40 1 -22 2 13 0 53 3 7结尾无空行 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.ArrayList;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int m = in.nextInt(); int n = in.nextInt(); int t1 = in.nextInt(); int t2 = in.nextInt(); int num = t1; int[][] main = new int[n][m]; for (int i = 0; i &lt; t1; i++) &#123; int col = in.nextInt(); int row = in.nextInt(); main[row][col] += in.nextInt(); &#125; for (int i = 0; i &lt; t2; i++) &#123; int col = in.nextInt(); int row = in.nextInt(); if (main[row][col] != 0) &#123; num++; &#125; main[row][col] += in.nextInt(); if(main[row][col] == 0)&#123; num--; &#125; &#125; System.out.println(m + &quot; &quot; + n + &quot; &quot; + num); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (main[j][i] != 0) &#123; System.out.println(i + &quot; &quot; + j + &quot; &quot; + main[j][i]); &#125; &#125; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/7-1 n以内素数个数","date":"2021-12-09T12:07:57.890Z","updated":"2021-12-01T13:18:26.000Z","comments":true,"path":"2021/12/09/PTA题目集/7-1 n以内素数个数/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/7-1%20n%E4%BB%A5%E5%86%85%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0/","excerpt":"","text":"7-1 n以内素数个数 (10 分) 请统计出n以内所有的素数个数。 输入格式:请给出最大整数以内的一个数字n。 输出格式:输出n以内素数的个数。 输入样例:在这里给出一组输入。例如： 123451000结尾无空行 输出样例:在这里给出相应的输出。例如： 1168 123456789101112131415161718192021222324import java.util.Scanner;import java.lang.Math;public class Main &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int count = 1; int n = input.nextInt(); boolean[] list = new boolean[n+1]; if (n &gt; 2) &#123; for (int i = 3; i &lt;= n; i += 2) &#123; if (!list[i]) &#123; for (int j = 2; j &lt;= n/i; j ++) &#123; list[i*j] = true; &#125; count++; &#125; &#125; System.out.println(count); &#125; else if (n == 2) System.out.println(count); else System.out.println(0);&#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/6-2 数组中的第k大数字","date":"2021-12-09T12:07:57.880Z","updated":"2021-12-01T13:15:56.000Z","comments":true,"path":"2021/12/09/PTA题目集/6-2 数组中的第k大数字/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/6-2%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E5%A4%A7%E6%95%B0%E5%AD%97/","excerpt":"","text":"6-2 数组中的第k大数字 (10 分) 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 其中： 1 &lt;= k &lt;= nums.length &lt;= 10^4 -10^4 &lt;= nums[i] &lt;= 10^4 函数接口定义：1public static int findKthLargest(int[] nums, int k) &#123; nums是整数数组，函数返回第k个最大元素的值。 裁判测试程序样例：1234567891011121314151617import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner (System.in); int n = sc.nextInt(); int k = sc.nextInt(); int[] nums = new int[n]; for(int i = 0 ; i &lt; n; i ++)&#123; nums[i] = sc.nextInt(); &#125; System.out.println(findKthLargest(nums, k)); &#125;&#125;/* 请在这里填写答案 */ 输入样例1：在这里给出一组输入。例如： 126 23 2 1 5 6 4结尾无空行 输出样例1：在这里给出相应的输出。例如： 123455结尾无空行 输入样例2：在这里给出一组输入。例如： 129 43 2 3 1 2 4 5 5 6结尾无空行 输出样例2：在这里给出相应的输出。例如： 123454结尾无空行 123456789101112131415161718192021222324252627282930313233public static int findKthLargest(int[] nums, int k) &#123; int left = 0; int right = nums.length - 1; quickSort(nums, left, right); return nums[nums.length - k]; &#125; public static void quickSort(int[] arr,int low,int high)&#123; int i,j,temp,t; if(low&gt;high)&#123; return; &#125; i=low; j=high; temp = arr[low]; while (i&lt;j) &#123; while (temp&lt;=arr[j]&amp;&amp;i&lt;j) &#123; j--; &#125; while (temp&gt;=arr[i]&amp;&amp;i&lt;j) &#123; i++; &#125; if (i&lt;j) &#123; t = arr[j]; arr[j] = arr[i]; arr[i] = t; &#125; &#125; arr[low] = arr[i]; arr[i] = temp; quickSort(arr, low, j-1); quickSort(arr, j+1, high); &#125;","categories":[],"tags":[]},{"title":"","slug":"PTA题目集/6-1 数组中是否存在重复元素","date":"2021-12-09T12:07:57.870Z","updated":"2021-12-01T13:14:46.000Z","comments":true,"path":"2021/12/09/PTA题目集/6-1 数组中是否存在重复元素/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/PTA%E9%A2%98%E7%9B%AE%E9%9B%86/6-1%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/","excerpt":"","text":"6-1 数组中是否存在重复元素 给定一个整数数组，判断是否存在重复元素。 如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 函数接口定义：1public static boolean containsDuplicate(int[] nums) 其中 nums是需要判断的数组。nums中有重复元素，返回true，否则返回false。 裁判测试程序样例：12345678910111213141516171819在这里给出函数被调用进行测试的例子。例如：import java.util.Arrays;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; int n = 0; Scanner sc = new Scanner(System.in); n = sc.nextInt(); int[] array = new int[n]; for(int i = 0; i &lt; n; i++)&#123; array[i] = sc.nextInt(); &#125; System.out.print(containsDuplicate(array)); &#125;/* 请在这里填写答案 */&#125; 输入样例1：在这里给出一组输入。例如： 1241 2 3 1结尾无空行 输出样例1：在这里给出相应的输出。例如： 12345true结尾无空行 输入样例2：在这里给出一组输入。例如： 1241 2 3 4结尾无空行 输出样例2：在这里给出相应的输出。例如： 12345false结尾无空行 输入样例3：在这里给出一组输入。例如： 12101 1 1 3 3 4 3 2 4 2结尾无空行 输出样例3：在这里给出相应的输出。例如： 12345true结尾无空行 123456789 public static boolean containsDuplicate(int[] nums) &#123; for(int i = 0 ; i &lt; nums.length ; i++)&#123; for(int j = i+1 ; j &lt; nums.length ; j++)&#123; if(nums[i] == nums[j]) return true; &#125; &#125; return false;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-12-09T12:07:56.630Z","updated":"2021-03-06T20:16:34.000Z","comments":true,"path":"2021/12/09/hello-world/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"diff算法","slug":"diff算法","date":"2021-12-01T11:56:45.000Z","updated":"2022-01-16T11:27:50.274Z","comments":true,"path":"2021/12/01/diff算法/","link":"","permalink":"https://wangmou-niubi.github.io/2021/12/01/diff%E7%AE%97%E6%B3%95/","excerpt":"","text":"1. 前言diff 算法是一种通过同层的树节点进行比较的高效算法，避免了对树进行逐层搜索遍历，所以时间复杂度只有 O(n)。diff 算法的在很多场景下都有应用，例如在 vue 虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较更新时，就用到了该算法。diff 算法有两个比较显著的特点： 比较只会在同层级进行, 不会跨层级比较。 在 diff 比较的过程中，循环从两边向中间收拢。 2. diff 流程本着对 diff 过程的认识和 vue 源码的学习，我们通过 vue 源码的解读和实例分析来理清楚 diff 算法的整个流程，下面把整个 diff 流程拆成三步来具体分析： 第一步vue 的虚拟 dom 渲染真实 dom 的过程中首先会对新老 VNode 的开始和结束位置进行标记：oldStartIdx、oldEndIdx、newStartIdx、newEndIdx。 1let oldStartIdx &#x3D; 0 &#x2F;&#x2F; 旧节点开始下标let newStartIdx &#x3D; 0 &#x2F;&#x2F; 新节点开始下标let oldEndIdx &#x3D; oldCh.length - 1 &#x2F;&#x2F; 旧节点结束下标let oldStartVnode &#x3D; oldCh[0] &#x2F;&#x2F; 旧节点开始vnodelet oldEndVnode &#x3D; oldCh[oldEndIdx] &#x2F;&#x2F; 旧节点结束vnodelet newEndIdx &#x3D; newCh.length - 1 &#x2F;&#x2F; 新节点结束下标let newStartVnode &#x3D; newCh[0] &#x2F;&#x2F; 新节点开始vnodelet newEndVnode &#x3D; newCh[newEndIdx] &#x2F;&#x2F; 新节点结束vnode 经过第一步之后，我们初始的新旧 VNode 节点如下图所示： 第二步标记好节点位置之后，就开始进入到的 while 循环处理中，这里是 diff 算法的核心流程，分情况进行了新老节点的比较并移动对应的 VNode 节点。while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。 1while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; ....//处理逻辑&#125; 接下来具体介绍 while 循环中的处理逻辑， 循环过程中首先对新老 VNode 节点的头尾进行比较，寻找相同节点，如果有相同节点满足 sameVnode（可以复用的相同节点） 则直接进行 patchVnode (该方法进行节点复用处理)，并且根据具体情形，移动新老节点的 VNode 索引，以便进入下一次循环处理，一共有 2 * 2 = 4 种情形。下面根据代码展开分析: 情形一：当新老 VNode 节点的 start 满足 sameVnode 时，直接 patchVnode 即可，同时新老 VNode 节点的开始索引都加 1。 12345if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125; 情形二：当新老 VNode 节点的 end 满足 sameVnode 时，同样直接 patchVnode 即可，同时新老 VNode 节点的结束索引都减 1。 12345else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125; 情形三：当老 VNode 节点的 start 和新 VNode 节点的 end 满足 sameVnode 时，这说明这次数据更新后 oldStartVnode 已经跑到了 oldEndVnode 后面去了。这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1。 123456else if (sameVnode(oldStartVnode, newEndVnode)) &#123;// Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125; 情形四：当老 VNode 节点的 end 和新 VNode 节点的 start 满足 sameVnode 时，这说明这次数据更新后 oldEndVnode 跑到了 oldStartVnode 的前面去了。这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加 1。 12345patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125; 如果都不满足以上四种情形，那说明没有相同的节点可以复用。于是则通过查找事先建立好的以旧的 VNode 为 key 值，对应 index 序列为 value 值的哈希表。从这个哈希表中找到与 newStartVnode 一致 key 的旧的 VNode 节点，如果两者满足 sameVnode 的条件，在进行 patchVnode 的同时会将这个真实 dom 移动到 oldStartVnode 对应的真实 dom 的前面；如果没有找到，则说明当前索引下的新的 VNode 节点在旧的 VNode 队列中不存在，无法进行节点的复用，那么就只能调用 createElm 创建一个新的 dom 节点放到当前 newStartIdx 的位置。 12345678910111213141516171819202122232425262728else &#123;// 没有找到相同的可以复用的节点，则新建节点处理 /* 生成一个key与旧VNode的key对应的哈希表（只有第一次进来undefined的时候会生成，也为后面检测重复的key值做铺垫） 比如childre是这样的 [&#123;xx: xx, key: &#x27;key0&#x27;&#125;, &#123;xx: xx, key: &#x27;key1&#x27;&#125;, &#123;xx: xx, key: &#x27;key2&#x27;&#125;] beginIdx = 0 endIdx = 2 结果生成&#123;key0: 0, key1: 1, key2: 2&#125; */ if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) /*如果newStartVnode新的VNode节点存在key并且这个key在oldVnode中能找到则返回这个节点的idxInOld（即第几个节点，下标）*/ idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) if (isUndef(idxInOld)) &#123; // New element /*newStartVnode没有key或者是该key没有在老节点中找到则创建一个新的节点*/ createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; else &#123; /*获取同key的老节点*/ vnodeToMove = oldCh[idxInOld] if (sameVnode(vnodeToMove, newStartVnode)) &#123; /*如果新VNode与得到的有相同key的节点是同一个VNode则进行patchVnode*/ patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) //因为已经patchVnode进去了，所以将这个老节点赋值undefined oldCh[idxInOld] = undefined /*当有标识位canMove实可以直接插入oldStartVnode对应的真实Dom节点前面*/ canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm) &#125; else &#123; // same key but different element. treat as new element /*当新的VNode与找到的同样key的VNode不是sameVNode的时候（比如说tag不一样或者是有不一样type的input标签），创建一个新的节点*/ createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; &#125; newStartVnode = newCh[++newStartIdx] &#125; 再来看我们的实例，第一次循环后，找到了旧节点的末尾和新节点的开头(都是 D)相同，于是直接复用 D 节点作为 diff 后创建的第一个真实节点。同时旧节点的 endIndex 移动到了 C，新节点的 startIndex 移动到了 C。 紧接着开始第二次循环，第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，diff 后创建了 C 的真实节点插入到第一次创建的 B 节点后面。同时旧节点的 endIndex 移动到了 B，新节点的 startIndex 移动到了 E。 接下来第三次循环中，发现 patchVnode 的 4 种情形都不符合，于是在旧节点队列中查找当前的新节点 E，结果发现没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 startIndex 移动到了 A。旧节点的 startIndex 和 endIndex 都保持不动。 第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 diff 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 startIndex 移动到了 B，新节点的 startIndex 移动到了 B。 第五次循环中，情形同第四次循环一样，因此 diff 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 startIndex 移动到了 C，新节点的 startIndex 移动到了 F。 这时候发现新节点的 startIndex 已经大于 endIndex 了。不再满足循环的条件了。因此结束循环，接下来走后面的逻辑。 第三步当 while 循环结束后，根据新老节点的数目不同，做相应的节点添加或者删除。若新节点数目大于老节点则需要把多出来的节点创建出来加入到真实 dom 中，反之若老节点数目大于新节点则需要把多出来的老节点从真实 dom 中删除。至此整个 diff 过程就已经全部完成了。 123456789if (oldStartIdx &gt; oldEndIdx) &#123; /*全部比较完成以后，发现oldStartIdx &gt; oldEndIdx的话，说明老节点已经遍历完了，新节点比老节点多， 所以这时候多出来的新节点需要一个一个创建出来加入到真实Dom中*/ refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue) //创建 newStartIdx - newEndIdx 之间的所有节点 &#125; else if (newStartIdx &gt; newEndIdx) &#123; /*如果全部比较完成以后发现newStartIdx &gt; newEndIdx，则说明新节点已经遍历完了，老节点多于新节点，这个时候需要将多余的老节点从真实Dom中移除*/ removeVnodes(oldCh, oldStartIdx, oldEndIdx) //移除 oldStartIdx - oldEndIdx 之间的所有节点 &#125; 再回过头看我们的实例，新节点的数目大于旧节点，需要创建 newStartIdx 和 newEndIdx 之间的所有节点。在我们的实例中就是节点 F，因此直接创建 F 节点对应的真实节点放到 B 节点后面即可。 3. 结尾最后通过上述的源码和实例的分析，我们完成了 Vue 中 diff 算法的完整解读。如果想要了解更多的 Vue 源码。欢迎进入我们的 github 地址（https://github.com/DQFE/vue）进行查看，里面对每一行 Vue 源码都做了注释，方便大家的理解。","categories":[],"tags":[]},{"title":"雨滴","slug":"雨滴","date":"2021-11-01T11:18:07.000Z","updated":"2021-11-01T11:30:06.000Z","comments":true,"path":"2021/11/01/雨滴/","link":"","permalink":"https://wangmou-niubi.github.io/2021/11/01/%E9%9B%A8%E6%BB%B4/","excerpt":"","text":"rainmeter皮肤编写教程 代码块 介绍 [Rainmeter] 放置一般设定。 [Variables] 存放变量。 [Meters] 实际测量值在屏幕的表现方式 [Rainmeter]Background=255, 0, 255 ——背景，可用BMP,JPG和PNG（带透明）图片！ 255, 0, 255表示透明，默认透明。 BackgroundMode=1 ——背景模式，0-Background定义的图片。，1-透明，2-纯色，3-缩放的图片。默认1 BackgroundMargins=10,10,10,10 ——定义背景图像的边缘，在BackgroundMode=3的时候也不会被缩放。 SolidColor=FFFF0080 SolidColor2=FF00FF40 ——如果BackgroundMode设置为2的时候，此项定义背景色及第二渐变颜色。 GradientAngle= ——如果Background模式设置为2的时候，此项定义颜色梯度（颜色渐变）的角度。角度以弧度制定义。 BevelType=0 ——此项描述的是纯背景颜色周围的斜缘边。0=无，1=凸起，2=凹陷。 Update=1000 ——Meters的更新时间，单位是毫秒，默认是1000即1秒。 TransitionUpdate=100 ——meter的过渡时间，默认是100 DynamicWindowSize=0 ——如果设置成1，窗口会在每次更新时进行大小重新计算，必要情况下会自动缩放窗口大小。 DragMargins= ——定义窗口不允许被拖动的区域。需要定义4个值并以逗号分隔。这个值定义的是不允许拖动的区域。负值是从对边开始计算的。 KeepOnScreen=0 ——设置成1则窗口始终保持在监视器的范围之内。（建议玩全屏降分辨率游戏的用户不要开启此项选项，这样会导致退出游戏后插件移位） Author=AuthorName ——皮肤作者的名字和E-Mail地址。该字符串会显示在关于的对话框内。 AppVersion=1001000 ——此插件支持的最低RM引擎版本。如果你认为没必要可以不写。 ——Major * 1000000 + Minor1 * 1000 + Minor2. eg: Rainmeter 0.11.4 是 11004 ，Rainmeter 1.0 是 1000000. LocalFont=#PROGRAMPATH#Fonts\\Digitle.ttf ——LocalFont2=[path]FilenameOfFont.ttf | .otf ——自定义字体文件位置，在meter中可以通过FontFace=调用字体，1.1版貌似要重启软件才能调用新字体。 [Variables]CityCode=123456 ——在meter中就可以通过”url=http://www.weather.com/#CityCode#.html&quot;调用。 以下是内置变量: #PROGRAMPATH# ——Rainmeter软件所在目录 (eg: C:\\Program Files\\Rainmeter). #SETTINGSPATH# ——Rainmeter设置文件Rainmeter.ini所在目录(eg: C:\\Documents and Settings{yourname}\\Application Data\\Rainmeter) #SKINSPATH# ——Rainmeter的皮肤所在目录(eg: C:\\Documents and Settings{yourname}\\My Documents\\Rainmeter\\Skins) #PLUGINSPATH# ——Rainmeter的插件所在目录(eg: C:\\Program Files\\Rainmeter\\Plugins) #ADDONSPATH# ——Rainmeter的扩展程序所在目录(C:\\Program Files\\Rainmeter\\Addons) #CURRENTPATH# ——某个皮肤(.ini文件)所在的目录 #CURRENTCONFIG# ——rainmeter中显示的皮肤名称 (eg: Enigma\\Sidebar) #WORKAREAX# ——皮肤工作面积的横向坐标 #WORKAREAY# ——皮肤工作面积的纵向坐标 #WORKAREAWIDTH# ——皮肤工作面积的宽 #WORKAREAHEIGHT# ——皮肤工作面积的高 #SCREENAREAWIDTH# ——显示器分辨率的宽 #SCREENAREAHEIGHT# ——显示器分辨率的高 [Metadata]Name=Title | Subtitle ——皮肤名称，副标题 Config=Root Skin Folder | Subfolders | Current Folder ——配置皮肤文件夹结构 Description=Point 1 | Point 2 | Point 3 ——皮肤的描述 Instructions=Point 1 | Point 2 | Point 3 ——皮肤的指令说明 Version=2.0 ——皮肤版本 Tags=Tag 1 | Tag 2 | Tag 3 ——标签 License=Creative Commons Attribution-Non-Commercial-Share Alike 3.0 ——许可 Variant=1 ——变动 Preview=#SKINSPATH#MyConfig\\Images\\Previews\\Preview.png ——皮肤缩略图 [Measure]Measure=Plugin 这里定义Measures，有效值如下： CPU 测算CPU负载，如需独立监控各核占用情况开启PerfMon插件。 Memory 测算记忆体总利用率。 PhysicalMemory 测算物理内存分配。 SwapMemory 测算虚拟内存分配。 网络流量NetIn 测算网络下载流量。 NetOut 测算网络上载流量。 NetTotal 测算网络总流量。 硬盘容量FreeDiskSpace 测算空闲硬盘总量。 PefMon 测算终端性能数据。 Uptime 显示系统开机后持续的时间，仅在STRING-meter下工作。 Plugin 调用外部插件定义Measures。 Registry 测算注册表值。 Time 测算即时时间和日期。 Calc 计算公式。 InvertMeasure ——如果设置成1，反转测量值。（e.g.将空闲硬体容量反转为目前硬体占用容量） IfAboveAction ——如果实际测量值超过设定值时执行的命令。这个动作在测定值超越设定值时仅会被执行一次，所以如果要再次执行此动作前测定值需低于设定值。 IfAboveValue ——IfAboveAction的设定值。 IfBelowAction ——如果实际测量值低于设定值时执行的命令。这个动作在测定值低于设定值时仅会被执行一次，所以如果要再次执行此动作前测定值需高于设定值。 IfBelowValue ——IfBelowAction的设定值。 IfEqualAction ——当测量值等于IfEqualValue定义的值时执行的命令。当测量值等于设定值时命令仅执行一次，如果需要再次执行，测量值必须先低于 或者高于设定值。值四舍五入到整数。 IfEqualValue ——IfEqualAction的设定值。 Disabled ——如果设置成1，在启动时不进行测量。 UpdateDivider ——此值决定着测量频率。此值于Update值绑定。比如Update=1000&amp;UpdateDivider=30，则没30s测算一次。此项默认值为1。 MaxValue ——测算最大值。 MinValue ——测算最小值。 Substitute ——此项可以替换关键词，必须成对出现并用逗号分隔，注意必须要用引号引出。（e.g.Substitute=“cat”:”dog”表述的是在测量值中将关键词cat全部替换成dog） AverageSize ——定义窗口的测量平均取值。（e.g.如果设置成10则将输出最后10次测量的平均值） CPU Processor ——设置为1至n，表示第1至n的CPU核心，如果不设或为0则返回所有CPU的平均值。 NetIn NetInSpeed ——用户网络接入最高速度。该值单位以1bit/s计。如果这个值缺损或者设置为0，这个值将以实际值决定。注意峰值。 TrafficAction ——当下载数据到达一定量时所执行的行为。 TrafficAction ——TrafficAction的设定值。 Interface ——网卡监测数据。如果此处被设置为0（默认值），所有的端口将被加在一起，如果值为1，则记录第一块网卡，2为第二块.etc.。 Cumulative ——如果设置成1，将监测数据累积(i.e.把监测数据加在一起)。这可以用来检测特定周期的交换数据总量。 NetOut NetOutSpeed ——（用户网络输出最高速度） etc. NetTotal NetTotalSpeed ——（用户网络输入输出最高速度） etc. FreeDiskSpace Drive ——检测的具体硬体。（e.g.“C:”） Total ——如果设置成1，则反馈数据显示硬体的总容量。 Label ——如果设置成1，则反馈数据显示驱动器标签。 InvertMeasure ——如果设置为1，这将返回“使用空间”而不是“自由空间”。 此设置并不限于FreeDriveSpace。 IgnoreRemovable ——默认值为1 - 可移动驱动器将被忽略。 如果设置为0，可移动驱动器进行测量。 Plugin Plugin ——定义实际测量时需用到的插件名。 Registry RegKey ——注册表项名。 RegHKey ——HKEY名。有效值有： ——HKEY_CURRENT_CONFIG, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_PERFORMANCE_DATA and HKEY_DYN_DATA. RegValue ——注册表项值名。仅支持字符串和长字符串。 Time Format ——时间表达格式（e.g.“%H:%M:%S”）。你可以从MSDN找到所有的代码格式。 TimeZone ——时区值（e.g.+2.0）. DaylightSavingTime ——如果设置成1则将开启夏令时（取决于你的本地时间）。这仅在时区TimeZone值被设定的情况下有效。 Calc Formula ——此项定义计算公式。你可以使用其他的Measures来作为Variables。这里还有一个特殊的变量称之为Counter，它在每次更新后增加。这个变量仅在所有其他的Measures更新完毕后更新。注意配置文件都区分大小写，所有的函数都必须大写(e.g.SIN(10*PI))。 基本运算： 1+（加） 、 -（减） 、 *（乘） 、 /（除） 、 **（幕） 、 %（余下或模） 、 &amp;（位与） 、 |（按位或） 、 ^（按位异或） 、 ~（按位不） 1逻辑运算符： 123&lt;&gt;（不等于）、 =（等于）、 &gt;（大于）、 &lt;（小于）、 &amp;&amp;（逻辑与）、 ||（逻辑或) 1函数:ATAN(x), ASIN(x), ACOS(x), COS(x), SIN(x), TAN(x) - 标准三角函数 ABS(x) - x绝对值. EXP(x) - 返回e^x的值. LN(x) - 返回x的自然对数. SQRT(x) - x的平方. SGN(x) - x是正数则返回1, 负数返回-1. FRAC(x) - 返回小数部分 (eg: FRAC(1.234) = 0.234). TRUNC(x) - 返回整数部分 (eg:TRUNC(1.234) = 1). FLOOR(x) - Floor of x. CEIL(x) - Ceiling of x. ROUND(x[,precision]) -四舍五入 Rounds x to an integer, or to a specified number of decimal places. Precision is optional. 条件运算符:? &lt;expr. if true.&gt; : &lt;expr. if false.&gt; 表示 if (condition) then expr. if true else expr. if false end if Example:[MeasureCalc] Measure=Calc Formula=(Random) LowBound=5 HighBound=100 ——表示返回5-100之间的随机数 UpdateRandom=1 —— 1表示每次循环就刷新随机函数，0表示刷新皮肤才刷新随机函数 [Meter]——每个meter都去要有一个唯一的名称，并在配置文件中加以定义。命名必须用“[]”符号括起。命名没有特别要求不过不要在一个配置文件中有重复出现，不要在命名中出现空格。 FontColor FontEffectColor SolidColor PrimaryColor SecondaryColor BothColor BarColor LineColor HorizontalLineColor MeasureName ——Meter表述的Measure名称。 X ——窗口内的X坐标，在结尾以加上“r”的形式可以将坐标与前一个meter相关联(e.g. X=5r)。也可以用大写“R”来与前一个Meter的右边缘关联。 Y ——窗口内的Y坐标，在结尾以加上“r”的形式可以将坐标与前一个meter相关联(e.g. Y=-10r)。也可以用大写“R”来与前一个Meter的底部边缘关联。 W ——Meter的宽度。如果你使用可计算出宽度的图片或者字符串表的话可以不需要做定义。如果你使用桌面作为整个RM的背景则需要定义所有插件的长度和宽度，不然窗口的尺寸可能出现计算错误的情况。 H——Meter的长度。其余同上“W”参数值。 Hidden ——如果设置成1则Meter隐藏。 LeftMouseDownAction RightMouseDownAction Lef tMouseUpAction RightMouseUpAction MouseOverAction MouseLeaveAction ——这些和全局设定效果相同，但仅应用于特定的Meter。此处的设置权限高于全局设置。 ——注意：当窗口被允许拖动的情况下LeftMouseUpAction无效。你需要用DragMargins定义可拖动区域以此来避免Meter的重叠操作。 UpdateDivider ——此值决定Meter的更新间隔。此值与Update值绑定。比如当Update=1000，UpdateDivider=30则Meter每30s更新一次。默认值为1. SolidColor ——Meter的背景色。 SolidColor2 ——第二颜色的背景梯度(颜色渐变的第二颜色)。 GradientAngle ——颜色梯度（颜色渐变）的角度。角度以弧度制定义。 BevelType ——此项描述的是纯背景颜色周围的斜缘边。0=无，1=凸起，2=凹陷。 AntiAlias ——设置为1，表示开启抗锯齿 MeterStyle ——表示公共stytle Example:[MyStringStyle] FontColor=#FontColor# FontFace=TheSansBold-Caps FontSize=11 StringEffect=SHADOW StringStyle=BOLD StringAlign=LEFT AntiAlias=1 ——Then in any meter, use: [Meter] Meter=STRING ——(or any other meter type) MeterStyle=MyStringStyle Meter的类型 介绍 BAR 条形图 BITMAP 位图 BUTTON 按钮 HISTOGRAM 直方图表 IMAGE 图像 LINE 线 ROTATOR 旋转 ROUNDLINE 圆点 线 STRING 字体 条形图[Bar] Meter=BAR BarColor ——Bar的颜色。 BarImage ——Bar的背景图片。这可以用来替代BarColor。 BarBorder ——此处定义Bar的边缘。 BarOrientation=HORIZONTAL ——Bar的方向性。有效值如下：HORIZONTAL(水平)、VERTICAL（垂直） Flip=0 ——如果设置为1则反转Bar的方向。 位图[Bitmap] Meter=BITMAP BitmapImage ——这是包含图像帧图像的名称。图像可以规定水平或垂直位图中。自动确定方向形成高度或宽度的位图（无论是较大）。同时，一个帧的大小则自动计算因此要裁剪图像，以便帧周围没有额外的空间。图像可以是任何受支持的格式： bmp gif，jpg 或 png。 如果 BitmapExtend 不是 1，然后位图米要求被使用的方法，是从 0.0 到 1.0 或有 MaxValue 和 MinValue 设置。 BitmapFrames ——图像中的帧数。 BitmapTransitionFrames ——每值过渡帧的数量。过渡帧帧的显示时，米的价值变化。过渡帧相同的数目，必须在每次使用常规框架。在[Rainmeter]部分TransitionUpdate设置确定在该帧过渡期间显示的汇率。过渡动画总期限因此TransitionUpdate * BitmapTransitionFrames。请注意，BitmapFrames始终定义的帧总数位图，包括过渡帧。因此，举例来说，如果位图有10个值，每个过渡，另外4架组成，然后BitmapFrames应设置为50 BitmapTransitionFrames 4。 Bitm apZeroFrame ——如果设置为 1，第一帧时使用只测量到的值为零。 否则帧所测量到的值线性决定。 BitmapExtend ——如果设置为 1 将扩展该位图，因此显示整个值。 示例，如果定义一个位图，它定义帧从 0 到 9，您可以使用此为位图数字 BitmapDigits ——位图动画的数目 BitmapAlign ——定义位图对齐方式LEFT, CENTER and RIGHT BitmapSeparation ——分离时BitmapDigits之间的数字高于1。 这也可以是负数。 位图例子Examples: [MeasureDate] Measure=Time Format=%d [MeterDate] MeasureName=MeasureDate Meter=BITMAP X=50 Y=0 BitmapImage=number.png BitmapFrames=10 BitmapExtend=1 BitmapDigits=2 BitmapAlign=CENTER 按钮[BUTTON] Meter=BUTTON ButtonImage ——按钮图像的名称。 图像必须具有 3 帧，可以设置水平或垂直方向确定图像的高度和宽度。在第一帧对应于正常他按钮的图像。单击该按钮时显示第二个帧。当鼠标悬停在按钮上时显示的第三个框架。 ButtonCommand ——命令或 ！ 邦，在按下该按钮时执行。 按钮例子Examples: [MeterNote] Meter=BUTTON X=0 Y=0 ButtonImage=Button.png ButtonCommand=!Execute [notepad] 直方图表[Histogram Meter] Meter=HISTOGRAM SecondaryMeasureName ——辅助度量值的名称。 这定义度量值为辅助的直方图绘制对同一个表。 不需要这定义，如果不需要其他计量器。 PrimaryColor ——主直方图的颜色。 与 SolidColor 相同，颜色载以同样的方式： RGB(A)。 SecondaryColor ——次直方图的颜色。 BothColor ——主和次直方图的相交时使用的颜色。 PrimaryImage ——用于后面辅助直方图的图像的名称。 您可以使用颜色或图像而不是都在同一时间。 因此，如果您定义 PrimaryImage 您还必须定义 SecondaryImage 和 BothImage 如果您有相同的直方图不是 SecondaryColor 或 BothColor 中的一项辅助措施。 SecondaryImage ——用于后面辅助直方图的图像的名称。 BothImage ——图像时，小学和中学的直方图是分开的基础上所使用的名称。 Autoscale ——如果设置为 1，直方图进行自动缩放以显示所有值。 Flip ——如果设置为 1 是翻转的样式。 直方图表案例Examples: [MeasureCPU] Measure=CPU [MeterCPU] MeasureName=MeasureCPU Meter=HISTOGRAM X=0 Y=0 W=100 H=20 PrimaryColor=0,0,0,200 SolidColor=255,255,255,200 BarOrientation=HORIZONTAL AntiAlias=1 图像[Image Meter] Meter=IMAGE ImageName ——图片的名称显示。 Path ——图像的路径。 该路径是相对于皮肤文件夹。 AntiAlias ——如果设置 为1，图像有抗锯齿插值应用程序时，它显示。 PreserveAspectRatio ——如果设置为1，以图像的宽高比缩放。 默认值为PreserveAspectRatio = 0 您可以使用 PreserveAspectRatio 指定 W 和 H = 0，和它将缩放图像精确指定的大小。不保留长宽比。 您可以使用 PreserveAspectRatio 指定 W 或 H 单 = 1，并将图像为给定的值与其他未定义”方面”被自动缩放以保留长宽比缩放。 您可以指定 W 和 H 与 PreserveAspectRatio = 1，并将使用较大的宽度或高度维度的设置为用户定义的值，原来的图像缩放图像和其他”方面”设置为所需保留长宽比。 这样该图像会向容器定义 W 和 H 的即使该用户不知道是否图像原本是”纵向”或”横向”（高或宽） 从源中”适合”。 在所有情况下，该图像”本”宽和 ·”死亡空间”创建者保持长宽比 （像在电视机上观看宽屏电影标准 4: 3 屏幕上的时，黑条) 所定义的表是透明的。 图像米作为 W 或 H 或两者，值，可以使用 [MeasureName]，并对每个度量值使用的更新进行图像缩放。这意味着一个刷新不需要调整图像大小，并动态”缩放”的图像可通过使用来更改大小值的措施。 Greyscale ——如果设置为1，该图片将显示为灰度。 如果指定，这是 ImageTint 或 ColorMatrix 之前应用 ImageTint ——以浅色图像颜色。 颜色载于时相同的方式，为 SolidColor: RGB(A)。 如果指定 alpha 值，则该图像，可以进行半透明 (0 表示不可见，255 表示完全不透明）。 默认值为白色 （255、 255、 255、 255)。 ColorMatrixN ——he ColorMatrix 参数表示一个用于处理图像的颜色值的 5 x 5 矩阵。它分为五个单独参数之一的每一行的每个编号。 默认矩阵，如下所示： ColorMatrix1=1—— 0—— 0—— 0—— 0 ColorMatrix2=0—— 1—— 0—— 0—— 0 ColorMatrix3=0—— 0—— 1—— 0—— 0 ColorMatrix4=0—— 0—— 0—— 1—— 0 ColorMatrix5=0—— 0—— 0—— 0—— 1 主对角线上的值是，从左上到右下： 红、 绿色、 蓝、 Alpha 和一个占位符。 值表示的当前在其中 0.0 是 none，1.0 是正常的图像中的特定值的百分比。矩阵中剩余的条目允许值修改的另一种颜色的颜色（恩：红的值可能有一半的蓝色增值)，直接添加到颜色的偏移的值确定最终行 (ColorMatrix5) 中的项。 （（例如： ColorMatrix5 = 0.5—— 0—— 0—— 0—— 1 将添加到红色的值的 50%)。一个更深层的解释将被列入对完全免除了 Rainmeter v1.2 教程。 ImageFlip ——“NONE”, “HORIZONTAL”, “VERTICAL” or “BOTH”.值为”NONE”、“卧式”、“立式”两者”。 ImageRotate ——图像旋转度的定义数量。 负数旋转逆时针方向。 图像案例Examples: [MeasureQuote] Measure=Plugin Pl ugin=Plugins\\QuotePlugin.dll PathName=”#PROGRAMPATH#Skins\\Tranquil” FileFilter=*.png [MeterImage] Meter=IMAGE MeasureName=MeasureQuote X=0 Y=0 W=150 H=150 PreserveAspectRatio=1 —— The following image would be greyscaled, then tinted orange: [MeterTintedImage] Meter=Image ImageName=image.png Greyscale=1 ImageTint=255,128,64,255 X=0 Y=0 W=200 H=200 Line[Line Meter] Meter=LINE LineCount ——表中的行数。 可以有任意数目的同一个表中的行。 在名称中的使用 [N] 设置必须具有用来定义的行的编号。请注意，第一行数没有 (ei： MeasureName、 LineColor 和规模都用于在第一的行号为后续行添加）。 MeasureName[N] ——行 [N] 的度量值的名称。 LineColor[N] ——N线的颜色。 与 SolidColor 相同，颜色载以同样的方式： RGB(A)。 Scale[N] ——行 [N] 的比例。 测量到的值乘以此值。 AutoScale ——如果设置为 1，行自动缩放，以便最大值是在油分计中可见。 如果设置为 0，计的规模是从使用该措施的所有的最大的最大值。 HorizontalLines ——如果设置为 1 的水平线直方图行后面绘制。 HorizontalLineColor ——水平的线条的颜色。 与 SolidColor 相同，颜色载以同样的方式： RGB(A)。 LineWidth ——行宽，以像素为单位的宽度。 Flip ——如果设置为 1 是翻转的样式。 Examples:[MeasureNetIn] Measure=NetIn [MeasureNetOut] Measure=NetOut [MeterNetwork] Meter=LINE MeasureName=MeasureNetOut MeasureName2=MeasureNetIn X=0 Y=0 W=100 H=20 LineCount=2 LineColor=221,53,174,200 LineColor2=0,0,0,200 SolidColor=255,255,255,200 AutoScale=1 AntiAlias=1 Rotator 图像[Rotator Meter] Meter=ROTATOR ——转子计显示图像，围绕旋转的角度位置确定一个点它附加到度量值。 转子米要求被使用的方法，是从 0.0 到 1.0 或有 MaxValue 和 MinValue 设置。 ImageName ——旋转图像的名称。 OffsetX ——的旋转中心的 X 偏移量。 offsetY ——Y 位移旋转的中心。 StartAngle ——行的角度开始。 这是弧度及零角度在右边。 defualt 旋转方向是顺时针方向。 RotationAngle ——大小的旋转角度为行。 逆时针方向旋转使用负值。 ValueRemainder ——使用其余部分而不是实际的测量值。 这可用于绘制模拟时钟。 Examples:[MeasureTime] Measure=Time [MeterHours] MeasureName=MeasureTime Meter=ROTATOR X=0 Y=0 W=30 H=30 ImageName=Hours.png StartAngle=6.2832 RotationAngle=6.2832 ValueReminder=43200 OffsetX=14.5 OffsetY=14.5 [MeterMinutes] MeasureName=MeasureTime Meter=ROTATOR X=0 Y=0 W =30 H=30 ImageName=Minutes.png StartAngle=6.2832 RotationAngle=6.2832 ValueReminder=3600 OffsetX=14.5 OffsetY=14.5 Roundline 围绕一个点的单个行[Roundline Meter] Meter=ROUNDLINE ——roundline 仪表显示围绕一个点的单个行。线条的角度确定度量值。默认情况下，最小位置指向该的权利在行然后移动顺时针，直到它再次指向右边。如果未定义宽度和高度的中心点是该油分计的 X 和 Y 位置。如果指定的宽度和高度多则是在外框的中间。 Roundline 米要求被使用的方法，是从 0.0 到 1.0 或有 MaxValue 和 MinValue 设置。 LineWidth ——行宽，以像素为单位的宽度 LineLength ——这定义线的长度。 从旋转 （无论是 LineStart 的值） 的中心始终测量长度。 ControlLength、 LengthShift ——如果 ControlLength 设置为 1，度量值控制从 LineLength 到 LineLength + LengthShift 的 LineLength。 LineStart ——这定义从该行开始处的中心的距离。 ControlStart、 StartShift ——如果 ControlStart 设置为 1，这项措施控制从 LineStart 到 LineStart + StartShift 的 LineStart。 StartAngle ——行起始角度。 这是以弧度表示，零角度是右侧。 默认旋转方向是顺时针方向。 ControlAngle、 RotationAngle ——除非 ControlAngle 设置为 0，这项措施控制从 0 到 RotationAngle 的 RotationAngle。 旋转角度行的大小。 逆时针方向旋转使用负值。 ValueRemainder ——使用其余部分而不是实际的测量值。 这可用于绘制一个模拟时钟。 LineColor ——线的颜色。 与 SolidColor 相同，颜色载以同样的方式： RGB(A)。 Solid ——设置为 1，计将绘制饼图-相反。 Examples:[MeasureDisk] Measure=FreeDiskSpace Drive=C: InvertMeasure=1 [MeterDisk] Meter=ROUNDLINE MeasureName=MeasureDisk X=0 Y=0 W=50 H=50 StartAngle=4.712 RotationAngle=6.283 LineLength=25 LineColor=0,0,0,200 Solid=1 AntiAlias=1 字体[String Meter] Meter=STRING ——字符串米以文本形式显示度量值的值。 字符串表不一定要有一个附加到它上面的措施，只是可以设置的文本字符串。 MeasureName# ——字符串米允许同时使用相同的米内的多个度量值。 若要指定其他措施，将追加一个数字，以”MeasureName”（如： MeasureName2，MeasureName3，等等…)。 FontColor ——文本的颜色。 与 SolidColor 相同，颜色载以同样的方式： RGB(A)。 Prefix ——值之前显示的字符串。 Postfix ——值之前显示的字符串。 FontFace ——字体的名称。 请注意这不是该字体文件，但本身的字体的名称。 FontSize ——字体的大小。 StringAlign ——字符串的对齐方式。 有效值 为: LEFT, CENTER and RIGHT。 StringStyle ——字符串的样式。 有效值为： NORMAL, BOLD, ITALIC and BOLDITALIC StringEffect ——字符串的影响。 有效值为： NONE, SHADOW and BORDER. FontEffectColor ——StringEffect 的颜色。 与 SolidColor 相同，颜色载以同样的方式： RGB(A)。 StringCase ——设置字符串的”案件”。 有效的值是NONE, UPPER, LOWER, PROPER。 Scale ——伸缩因子的测量到的值。 测量到的值是 划分 为规模值因此为了获得 1000年倍较小值只是集规模为 1000年。如果缩放值有小数点 （如： 1000.0) 所得到的测量的值显示为浮动点与一个十进制值。 AutoScale ——如果设置为 1，值自动缩放。 此设置将覆盖规模。 值是自动后缀与 T、 G、 M 或 k 取决于它多少缩放。 percentual ——如果设置为 1，值将显示为一个百分比。 NumOfDecimals ——显示值中使用的小数位数。 Text ——显示的文本。 在字符串中使用 %1，以显示测量的值。 如果这绑定到几个措施只是使用 %2，%3 等为不同的值。 ClipString ——如果计量器的宽度设置为 1 修剪字符串。 一个省略号 (…) 将被添加到字符串的末尾。必须指定宽度和高度。是否足够大，以便另一行文本的高度它会使文本换行分成两个或多个行的而不是使用省略号。 Angle ——这定义文本的角度。 给出以弧度表示值。 请注意大小和文本的位置仍计算文本是水平。 Examples:[MeasureDate] Measure=Time [MeterDate] MeasureName=MeasureDate Meter=STRING X=0 Y=0 FontColor=0,0,0,255 FontFace=“Trebuchet MS” FontSize=20 StringEffect=BORDER FontEffectColor=255,255,255,255 AntiAlias=1 音乐播放[Sound] PLAY [soundfile] ——播放指定的声音一次。 PLAYLOOP [soundfile] ——循环播放指定的声音。 PLAYSTOP ——停止播放声音。 Example:——这会创建一个按钮，在单击时播放”beep.wav”。 [BeeperButton] Meter=Button ButtonImage=button.png ButtonCommand=PLAY #SKINSPATH#Beeper\\Sounds\\beep.wav 控制 Rainmeter[Bangs] ——Rainmeter也可以控制的！邦命令。阿爆炸是一个特殊的命令可以执行更改应用程序中的东西。您可以使用在各种行动Rainmeter了，或他们运行在命令行给予作为Rainmeter.exe论点爆炸。 请注意，[]意味着你必须提供的爆炸参数（不包括[] -字符）。的（）表示该参数是没有必要的。 大多数！邦斯作为可选参数还配置。如果配置大爆炸定义只适用于特定的配置。如果它没有得到的！邦被送到电流（皮肤）或第（命令行）配置。使用*作为配置的名称将其发送给所有configs。 !RainmeterShow (Config) — —显示 Rainmeter 窗口。 !RainmeterHide (Config) ——隐藏 Rainmeter-窗口。 !RainmeterToggle (Config) ——Rainmeter 窗口之间切换。 !RainmeterRefresh (Config) ——重新加载配置文件。 该参数是可选的。 如果未指定当前配置被重新加载。 已加载的配置列表中必须存在配置和 IniFile。 !RainmeterRedraw (Config) ——强制将重绘的窗口。 这也将更新所有 meters。 !RainmeterHideMeter [Meter] (Config) ——隐藏给定的表。 请注意隐藏表不会停止测量，您还需要禁用度量值，如果你不想花费额外的 CPU 周期，测试。 !RainmeterShowMeter [Meter] (Config) ——显示给定的表，如果它被隐藏。 !RainmeterToggleMeter [Meter] (Config) ——切换给定表的可见性。 !RainmeterMoveMeter [X] [Y] [Meter] (Config) ——移动给定的表（即不是窗口，但米）到新的位置。 !RainmeterDisableMeasure [Measure] (Config) ——禁用给定的监测。 !RainmeterEnableMeasure [Measure] (Config) ——开启指定的监测。 !RainmeterToggleMeasure [Measure] (Config) ——切换给定措施的状态（即禁用/启用）。 !RainmeterActivateConfig [Config] [Ini-file] ——激活新配置的 ini 文件。 该 ini 文件是就该文件的名称，并不包括路径。 !RainmeterDeactivateConfig [Config] ——停用配置的 ini 文件。 !RainmeterToggleConfig [Config] [Ini-file] ——切换配置的 ini 文件。 !RainmeterMove [X] [Y] (Config) ——移动到新的窗口位置。 !RainmeterZPos [POS] (Config) ——更改窗口的 z 位置。 -2 = OnDesktop，-1 = OnBottom，0 = 正常，1 = OnTop，2 = 最顶层。 !RainmeterAbout ——打开关于对话框。 !RainmeterLsBoxHook [Config] ——lsBox 的特殊邦。 请注意您必须提供作为参数配置的名称。 !RainmeterResetStats ——重置统计信息。 !RainmeterPluginBang “[MeasureName] [Arguments]” ——发送到一个插件的一个邦。 该参数必须在引号内。 在 MeasureName 中定义处理该插件，该插件。参数依赖于该插件。 !Execute ——特别 ！ 可以被用来合并几个邦 ！ 一起 bangs。 在 ！ 重击用分隔 [和]-字符。 您还可启动此应用程序 （！ 执行 [C:\\Windows\\Notepad.exe]) !RainmeterQuit ——退出 Rainmeter。 !RainmeterSetVariable [Variable] [Value] (Config) ——设置一个新值的变量。 米或度量值使用变量的位置，必须启用动态变量 (DynamicVariables = 1)。可以使用公式，括在括号中。 与所有一样 ！ 男孩，引号必须使用该参数周围，如果有空格： ！ RainmeterSetVariable VarName”(# SCREENAREAWIDTH # 10)” !RainmeterRefreshApp ——的所有外观的完全刷新并重新加载配 置和 Rainmeter.ini 设置的列表。这是”全部刷新”相同的系统任务栏的上下文菜单。不是相同 ！ RainmeterRefresh [配置 | *]，它可用于使 Rainmeter 看到一个新的文件夹添加到 \\Skins 的用户或进程。 !RainmeterSetTransparency [AlphaAmount] (Config) ——外观的透明度从集 0 （不可见的） 到 255 （不透明）。 !RainmeterShowFade (Config), !RainmeterHideFade (Config), !RainmeterToggleFade (Config) ——显示或隐藏当前或指定 (Config) 皮肤使用一个”淡出”效果。 在淡入淡出的速度由在”FadeDuration =”设置为 Rainmeter.ini 的皮肤。 Rainmeter 插件是导出 （这是不需要导出所有这些） 这些函数的 DLL： UINT Initialize(HMODULE instance, LPCTSTR iniFile, LPCTSTR section, UINT id) —— void Finalize (HMODULE 实例，UINT id) —— UINT Update(UINT id) 双 Update2(UINT id) LPCTSTR GetString(UINT id, UINT flags) 度量值初始化时调用此 初始化 函数。 该函数返回的最大值，可以测量。 如果最大值是未知函数应返回 0。该插件还可以自己设置，可以从该 iniFile 和给作为参数初始化函数部分加载。 id 参数用于标识个别措施，如果有几个都使用相同的插件。 删除度量值时，调用 Finalize。 更新 更新周期每一次调用 （通常一次每秒)。 该函数返回测量到的值。 Update2 是，如果度量值，返回值为负，则可以使用该函数的替代版本。 GetString 计需要作为字符串值时调用。 如果没有执行此函数返回由 更新 的值会自动转换为字符串。 请检查 Rainmeter 源有关如何实现一个插件的示例。 [AdvancedCPU Plugin] Plugin=Plugins/AdvancedCPU.dll CPUInclude ——的进程名名单中包含了CPU测量。 的名字(“——“-分号分隔字符）。 该清单将覆盖包括排除。 CPUExclude ——进程名称的列表被排除CPU的测量。 的名字(“——“-分号分隔字符）。 该清单包括：必须是空的东西排除在外。 TopProcess ——值2返回的进程了自上次更新最CPU时间的名称。值为1返回该进程的CPU时间。请注意，这将返回CPU时间，而不是百分比。如果你一次测量值每秒可以规模100000的价值得到的百分比，但你应该注意，如果值是无法测量excatly每秒一次（喜欢它，因为通常不能在 Windows计时器是不准确的），你可能获取值大于100％。 例如：——显示名称和CPU使用率最高的进程： [MeasureTopProcess] Measure=Plugin Plugin=Plugins\\AdvancedCPU.dll TopProcess=2 CPUExclude=Idle [MeasureTopProcess2] Measure=Plugin Plugin=Plugins\\AdvancedCPU.dll TopProcess=1 CPUExclude=Idle [MeterTopProcess] Meter=STRING X=0 Y=0 MeasureName=MeasureTopProcess MeasureNam e2=MeasureTopProcess2 Text=”%2 (%1%)” NumOfDecimals=1 Scale=100000 [iTunes (v1.001) Plugin] Plugin=Plugins/iTunesPlugin.dll ——此插件可以用于远程控制 iTunes，并从中获取信息。 ——因为讨厌iTunes，所以不翻译 Examples:[MeasurePlay] Measure=Plugin Plugin=Plugins\\iTunesPlugin.dll Command=Play [MeterPlay] Meter=IMAGE X=40 Y=110 ImageName=img\\play.png LeftMouseDownAction=!execute [!RainmeterPluginBang “MeasurePlay”] [MeasureCurrentTrackArtwork] Measure=Plugin Plugin=Plugins\\iTunesPlugin.dll Command=GetCurrentTrackArtwork DefaultArtwork=img\\defaultartwork.png [MeterCurrentTrackArtwork] Meter=IMAGE X=170 Y=10 W=80 H=80 ImageName=”%1” MeasureName=MeasureCurrentTrackArtwork [MBM5 Plugin] Plugin=Plugins/MBM5Plugin.dll————————————————版权声明：本文为CSDN博主「Aenm」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_44567078/article/details/109264686","categories":[],"tags":[]},{"title":"中国菜刀","slug":"中国菜刀","date":"2021-10-28T03:10:23.000Z","updated":"2022-01-16T11:32:07.722Z","comments":true,"path":"2021/10/28/中国菜刀/","link":"","permalink":"https://wangmou-niubi.github.io/2021/10/28/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80/","excerpt":"","text":"中国菜刀的由来： 说起菜刀，就不得不提起菜刀的作者，作者是一个退伍军人，生长在一个贫穷的农村，据说初中也没读完，英语更是不咋地，但他却自学掌握了C++/J2ME/PHP/JSP/ASP.NET等等十数种计算机语言，当初在六七年前台湾闹独立的时候，他在国民党和民进党的网站上留下了“只有一个中国”的黑页，一举成名。 作者是一个朴实，低调的技术牛人，他这些年留下的作品很多，中国菜刀是他最新的一个作品，从他之前的作品WEBSHELL管理器的基础上修改而来，功能更加的强大。 中国菜刀是一款专业的网站管理软件，用途广泛，使用方便，小巧实用。只要支持动态脚本的网站，都可以用中国菜刀来进行管理！程序大小：214K，在非简体中文环境下使用，自动切换到英文界面。UINCODE方式编译，支持多国语言输入显示。 主要功能有：文件管理，虚拟终端，数据库管理。 \\1. 文件管理：[特色]缓存下载目录，并支持离线查看缓存目录; 2.虚拟终端：[特色]人性化的设计，操作方便;(输入HELP查看更多用法) 3.数据库管理：[特色]图形界面,支持YSQL,MSSQL,ORACLE,INFOMIX,ACCESS 以入支持ADO方式连接的数据库。 只要往目标网站中加入一句话木马，然后你就可以在本地通过中国菜刀chopper.exe即可获取和控制整个网站目录。 什么是一句话木马？ 一句话木马就是一句简单的脚本语言，常见脚本语言的一句话木马如下： php： asp：&lt;%eval request (“pass”)%&gt; aspx：&lt;%@ Page Language=”Jscript”%&gt; &lt;%eval(Request.Item[“pass”],”unsafe”);%&gt; 一句话木马的使用 以php一句话为例，我们可以直接将这些语句插入到网站的某个php文件上，或者直接创建一个新的文件，在文件里写入一句话木马，然后把文件上传到网站上即可。 假设有个智障网站有这样的漏洞： 我们把这个phpma.php上传上去后，打开中国菜刀，在空白处鼠标右键，选择“添加选项” 编辑相关参数，包括一句话木马所在的URL以及密码，最后点击“编辑” 。 在URL中选中目标网站，点击鼠标右键，选择“文件管理”，就能看到网站的目录结构了 。 获取整个网站的目录，然后就可以开始做坏事了。","categories":[],"tags":[]},{"title":"汇编语言","slug":"汇编语言","date":"2021-09-28T11:08:40.000Z","updated":"2022-01-16T11:30:37.851Z","comments":true,"path":"2021/09/28/汇编语言/","link":"","permalink":"https://wangmou-niubi.github.io/2021/09/28/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","excerpt":"","text":"1、指令机器指令：CPU能直接识别并执行的二进制编码 汇编指令：汇编指令是机器指令的助记符，同机器指令一一对应。 指令：指令通常由操作码和地址码（操作数）两部分组成 指令集：每种CPU都有自己的汇编指令集。 汇编语言由3类指令组成。 汇编指令伪指令：没有对应的机器码，由编译器执行，计算机并不执行其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。 原文链接：https://blog.csdn.net/qq_39654127/article/details/88698911 123456; R 查看、修改CPU中寄存器的内容; D 查看内存中的内容; E 修改内存中的内容（可以写入数据、指令）; U 将内存中的内容解释为机器指令和对应的汇编指令; T 执行CS:IP指向的内存单元处的指令; A 以汇编指令的形式向内存中写入指令 汇编命令汇编语言Debug命令详解DEBUG的常用命令：A,U,R,T,D,E,Q 等等 汇编语言DEBUG命令详解文章目录汇编语言DEBUG命令详解R命令的使用H命令的使用D命令的使用E命令的使用F命令的使用M命令的使用C命令的使用S命令的使用A命令的使用G命令的使用U命令的使用N命令的使用W命令的使用L命令的使用T命令的使用P命令的使用I命令的使用O命令的使用Q命令的使用 R命令的使用作用：观看和修改寄存器的值。在提示符“-”下输入以下命令：R。DEBUG将会显示出当前所有寄存器和标志位的状态。接下来再输入命令rax。在提示符“：”后输入100。该命令的作用是将寄存器ax的值设置为100（注意：DEBUG使用的是十六进制，这里的100相当于十进制的256。）最后再执行r命令，观看修改后的寄存器值。 H命令的使用H命令作用：计算两个十六进制数的和与差。在提示符“–”下输入以下命令：h 10 1。观看命令执行结果。 运行结果的前一个数是计算出来的和，后一个数是计算出来的差。计算结果均用十六进制形式表示。 D命令的使用D命令作用： 。在提示符“–”下连续执行命令R、D、D。观看命令执行结果。 前面已经介绍过了，命令R的作用是显示当前寄存器的值。而命令D的作用是显示内存区域的内容，最左边是内存的起始地址，中间以十六进制的形式显示内存值，最右边是以ASCII码的形式显示内存值。每行最多显示16个字节的内容。命令D可以带参数也可省略参数。设DEBUG启动时DS的值为X，当省略参数时，命令D显示内容以X：100为起始，每次显示128个字节的内容。以后再执行不带参数的命令D时，DEBUG将按上次的位置接着显示下去。带参数时DEBUG能够显示指定地址范围的内容。带参数的方式有三种：方式一：**d [起始位置]**。DEBUG从起始位置开始显示128个字节的内容。在提示符“-”下执行命令d 1000:100。观看命令执行结果。 方式二：**d [起始位置] [结束位置]**。DEBUG从起始位置开始一直显示到结束位置。在提示符“-”下执行命令d 1000:100 200。观看命令执行结果。 方式三：**d [起始位置] [L长度]**，长度以L参数为标识。DEBUG从起始位置开始显示指定长度的内容。在提示符“-”下执行命令d ds:100 L10。观看命令执行结果。 E命令的使用E命令作用：改变内存单位的内容。E命令的使用方式为：E [起始位置]。在提示符“-”下输入以下命令： 1e 1000:100 。 DEBUG首先显示[1000:100]的内容01.，这时可以修改该字节的值。如果还要修改后续的内容，可以按空格键继续。当要跳过某个字节时，可以按连续的两个空格跳到后一个字节去。 F命令的使用F命令作用：使用指定的值填充指定内存区域中的地址。F命令的使用方式为：F [范围] [填充列表]。在提示符“-”下输入以下命令： 1F 1AF5:100 L20 1 2 3 4 5 。执行命令D 1AF5:100观看命令执行结果。 说明：该命令是用字节序列01、02、03、04、05轮流填充从1AF5:100开始长度为20H的内存区域。在提示符“-”下输入以下命令： 1F 1AF5:100 13F 41 42 43 44 。 说明：该命令是用字节序列41、42、43、44轮流填充从1AF5:100开始一直到1AF5:13F的内存区域。 M命令的使用M命令作用：将指定内存区域的数据复制到指定的地址去。M命令的使用方式为：M [范围] [指定地址]。在提示符“-”下输入以下命令：M 1AF5:100 13F 1AF5:140。执行命令D 1AF5:100观看命令执行结果。 C命令的使用C命令作用：将两块内存的内容进行比较。C命令的使用方式为：**C [范围] [指定地址]**，意思就是将指定范围的内存区域与从指定地址开始的相同长度的内存区域逐个字节进行比较，列出不同的内容。在提示符“-”下输入以下命令： 1C 1AF5:100 13F 1AF5:140 。由于两块内容完全相同，所以命令执行后没有任何显示。在提示符“-”下输入以下命令： 1C 1AF5:100 107 1AF5:180 ，比较的区域长度为8个字节。命令执行后列出比较结果不同的各个字节。 S命令的使用S命令作用：在指定的内存区域中搜索指定的串。S命令的使用方式为：S [范围] [指定串]。在提示符“-”下输入以下命令：D 1AF5:100 11F。显示该区域的内存值。在提示符“-”下输入以下命令：S 1AF5:100 11F 41 42 43 44。搜索该区域是否存在字节串41 42 43 44，并将搜索结果一一列出。 从执行结果可以看出，总共搜索到八处。 A命令的使用A命令作用：输入汇编指令。以下的程序要在屏幕上显示“ABCD”四个字符。首先用E命令将“ABCD” 四 个 字 符 预 先 放 在 内 存 C S : 200 处 ， 然 后 执 行 A 100 命 令 输 入 汇 编 程 序 代 码 ： 1234567891011MOV AX , CS MOV DS , A X MOV DX , 200 MOV AH , 9 INT 21 INT 20 （说明：前两行汇编指令用于将段寄存器CS的值赋给段寄存器DS。第三到第五行汇编代码的作用是显示以“”四个字符预先放在内存CS:200处，然后执行A100命令输入汇编程序代码： 1234567891011MOV AX,CSMOV DS,AX MOV DX,200MOV AH,9 INT 21 INT 20 （说明：前两行汇编指令用于将段寄存器CS的值赋给段寄存器DS。第三到第五行汇编代码的作用是显示以“”为结尾的字符串。最后一行用于结束程序。） G命令的使用G命令作用：执行汇编指令。G命令的使用方法是：**G [=起始地址] [断点地址]**，意思是从起始地址开始执行到断点地址。如果不设置断点，则程序一直运行到中止指令才停止。在设置完示例九的的内存数据并且输入完示例九的程序后运行这些汇编代码。在DEBUG中执行命令 1G&#x3D;100 ，观看运行结果。 汇编程序运行后在屏幕上显示出“ABCD”四个字符。 接下来在DEBUG中执行G=100 10B，意思是从地址CS：100开始，一直运行到CS：10B停止。观看运行结果。命令执行后，不但显示出字符串“ABCD”，而且列出当前寄存器和标志位的值。 g命令在loop中的使用：使用loop循环时，如果要跳出循环执行后面的代码，可以先用u命令查看代码的偏移地址，再用g命令跳转到此偏移到此代码处，如下： 用u命令可以看到循环的命令位于0b40:000b，所以要跳出循环就用 1g 000b 即可。 U命令的使用U命令作用：对机器代码反汇编显示。U命令的使用方法是：**U [范围]**。如果范围参数只输入了起始地址，则只对20H个字节的机器代码反汇编。 执行命令 1U100 ，观看反汇编结果。 执行命令 1U 100 10B ，观看反汇编结果。该命令的作用是对从100到10B的机器代码进行反汇编。 N命令的使用N命令作用：设置文件名，为将刚才编写的汇编程序存盘做准备。以下的DEBUG命令序列作用将刚才的汇编程序存为磁盘的COM可执行程序。 123456D200 20FU100 10CN E:\\FIRST.COMRCX:110W 第一和第二条命令的作用是检查一下刚才编写的汇编指令 。第三条命令的作用是设置存盘文件名为E:\\FIRST.COM， 第四条命令的作用是设置存盘文件大小为110H个字节。 最后一条命令是将文件存盘。 文件存盘后执行E:\\FIRST.COM，观看存盘的可执行文件的运行效果。 W命令的使用W命令作用：将文件或者特定扇区写入磁盘。在示例“N命令的使用”中已经实验了如何使用W命令将文件存盘。在没有很好地掌握汇编语言和磁盘文件系统前，暂时不要使用W命令写磁盘扇区，否则很容易损坏磁盘文件，甚至破坏整个磁盘的文件系统。 L命令的使用L命令作用：从磁盘中将文件或扇区内容读入内存。将文件调入内存必须先用DEBUG的N命令设定文件名。以下例子是将E:\\FIRST.COM读入内容。 12N FIRST.COML 观看调入程序的汇编代码可以使用DEBUG的U命令，用U100观看调入的COM文件。 读取磁盘扇区的方式是：L [内存地址] [磁盘驱动器号] [起始扇区] [扇区数]。 “内存地址”指定要在其中加载文件或扇区内容的内存位置，如果不指定“内存地址”的话，DEBUG将使用CS寄存器中的当前地址。 “磁盘驱动器号”指定包含读取指定扇区的磁盘的驱动器，该值是数值型：0=A，1=B，2=C等。 “起始扇区”指定要加载其内容的第一个扇区的十六进制数。“扇区数”指定要加载其内容的连续扇区的十六进制数。只有要加载特定扇区的内容而不是加载文件时，才能使用[磁盘驱动器号] [起始扇区] [扇区数]参数。例如：要将C盘第一扇区读取到内存DS:300的位置，相应的DEBUG命令为L DS:300 2 1 1。但是由于Windows操作系统对文件系统的保护，这条命令可能会被操作系统禁止运行。 T命令的使用T命令作用：执行汇编程序，单步跟踪。T命令的使用方式是T [=地址] [指令数]。如果忽略“地址”的话，T命令从CS:IP处开始运行。“指令数”是要单步执行的指令的数量。以下示例对E:\\FIRST.COM进行单步跟踪。 123456N E:\\FIRST.COMLU100 10BRT&#x3D;100T 第一、二条命令是装入文件，第三条命令是列出程序反汇编代码，第四条命令是显示当前寄存器值，第五条命令是从CS:100处开始单步跟踪，第六条命令是继续跟踪后续的指令。 P命令的使用P命令作用：执行汇编程序，单步跟踪。与T命令不同的是：P命令不会跟踪进入子程序或软中断。P命令的使用方式与T命令的使用方式完全相同。 p命令还可以用于结束本次循环，进入下一次循环。 I命令的使用I命令作用：从计算机输入端口读取数据并显示。I命令的用法是I [端口地址]。例如从3F8号端口读取数据并显示的命令为：I 3F8。这里不对该命令做解释。 O命令的使用O命令作用：向计算机输出端口送出数据。O命令的用法是O [端口地址] [字节值]。例如向278号端口发出数据20H的命令为：I 278 20。这里不对该命令做解释。 Q命令的使用Q命令的作用是退出DEBUG，回到DOS状态。 来源：https://www.cnblogs.com/tiger2soft/p/5094917.html————————————————版权声明：本文为CSDN博主「weixin_43809545」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_43809545/article/details/103640185","categories":[],"tags":[]},{"title":"Vue3","slug":"Vue3","date":"2021-09-06T07:38:41.000Z","updated":"2021-09-06T07:38:42.000Z","comments":true,"path":"2021/09/06/Vue3/","link":"","permalink":"https://wangmou-niubi.github.io/2021/09/06/Vue3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"CheatEngine","slug":"CheatEngine","date":"2021-08-28T05:52:03.000Z","updated":"2022-01-16T11:26:21.626Z","comments":true,"path":"2021/08/28/CheatEngine/","link":"","permalink":"https://wangmou-niubi.github.io/2021/08/28/CheatEngine/","excerpt":"","text":"基本步骤：1.根据相应数据类型以及将可写设为全黑方框后对初始值或者大概值进行搜索 2.改变值观察变化，通过不断的改变（增加或者删除）来减少范围，选取最有可能的那些值进行修改观察变化。 锁血就是将数值锁定 ==游戏内的道具栏之类的偏移可能是固定的。例如道具栏一和道具栏二的偏移为+90，那我们就能通过这个偏移来获得其他道具栏的地址。== 快速找到基址和指针基址为模块的入口（“ …… . exe”）最下面个是一级指针，是已经经过了偏移的结果 地址为基址加上随机的偏移而产生的，级数就是偏移的次数（下图为五级），32位游戏普遍为四级、五级，64位游戏则有可能十级、十二级等。 方法一 找到地址后双击， 双击进入后 复制可能值 使用十六进制去搜索， 再找一个，如此反复。可能会找到，但是这种方法80%游戏都不行。 方法二 指针扫描（ce官方） 最大等级64位的需要到12级左右，搜索很慢 以下是32位的大概设置 基址一般偏向游戏主模块地址本身。而不是dll 之后重新进入游戏或者重启游戏，修改数值得到数值地址后用地址去指针扫描。 要是你的汇编语言很牛逼，你完全可以自己去找QAQ 三、通过一个地址找到其他地址（道具栏找背包）搜索里的全部默认为float double 4字节 找出道具栏地址来点击这个。 改变后会有下面弹窗。 双击后得到信息 进入显示反汇编 找到改写了我们的代码（可能这个指令就是改写其他东西的指令） 改动数值后会有下列情况 通过不断修改道具栏，可能就可以获得道具栏所有地址 再去试试修改背包。 就得到了背包的地址 原理： 优秀的制作者会用一个函数去修改很多东西，来简化程序，这样就不会那么复杂。 这也可能导致我修改了我为无敌，导致敌人也无敌了 可以通过结构扫描，解析结构等方法来找出哪个是自己，哪个是敌人","categories":[],"tags":[]},{"title":"算法","slug":"算法","date":"2021-08-27T07:03:11.000Z","updated":"2022-01-16T11:31:34.805Z","comments":true,"path":"2021/08/27/算法/","link":"","permalink":"https://wangmou-niubi.github.io/2021/08/27/%E7%AE%97%E6%B3%95/","excerpt":"","text":"所有动图和静态图片均非本人制作，笔记大多数借鉴了别人的博客，如果全部复制过来的已经附上原文链接以及声明。笔记只是为了让自己理解算法而编写。 理解排序算法的稳定性稳定性：稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。 当相等的元素是无法分辨的，比如像是整数，稳定性并不是一个问题。然而，假设以下的数对将要以他们的第一个数字来排序。 1(4, 1) (3, 1) (3, 7)（5, 6） 在这个状况下，有可能产生两种不同的结果，一个是让相等键值的纪录维持相对的次序，而另外一个则没有 12(3, 1) (3, 7) (4, 1) (5, 6) （维持次序）(3, 7) (3, 1) (4, 1) (5, 6) （次序被改变） 不稳定排序算法可能会在相等的键值中改变纪录的相对次序，但是稳定排序算法从来不会如此。不稳定排序算法可以被特别地实现为稳定。作这件事情的一个方式是人工扩充键值的比较，如此在其他方面相同键值的两个对象间之比较，（比如上面的比较中加入第二个标准：第二个键值的大小）就会被决定使用在原先数据次序中的条目，当作一个同分决赛。然而，要记住这种次序通常牵涉到额外的空间负担。————————————————版权声明：本文为CSDN博主「黄大堂」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https:blog.csdn.netqq_43721542articledetails106001300 java对象排序要求稳定！！！ 提示：对于一些计算可以使用位运算比如：a2 写成 a &gt;&gt; 1 一、选择排序（没用，不稳定，慢，占空间） 大概：通过找到最小的那个依次放到前面来实现排序。 1234567891011121314151617181920212223242526void SimpleSelectSort(int *arr,int len)&#123; int min; for (int i = 0;i &lt; len - 1;i++) &#123; min = i; for (int j = i + 1;j &lt; len;j++) &#123; if (arr[min] &gt; arr[j]) &#123; min = j; &#125; &#125; if (min != i) &#123; Swap(arr,min,i); &#125; &#125;&#125;void Swap(int *arr, int a, int b)&#123; int tmp = arr[a]; arr[a] = arr[b]; arr[b] = tmp;&#125; 二、冒泡排序（基本）大概：通过从头开始和后一位比较来判断是否交换来确定最大值，进行排序。 1234567891011for(int i=0;i&lt;numbers.length-1;i++) &#123; for(int j=0;j&lt;numbers.length-1-i;j++) &#123; if(numbers[j]&gt;numbers[j+1]) &#123; int temp=numbers[j]; numbers[j]=numbers[j+1]; numbers[j+1]=temp; &#125; &#125; 三、插入排序（基本有序数组中最好用的 稳定 ）大概：像打牌一样，把数插到合适的位置。 123456789101112131415161718192021222324252627282930313233void InsertSort(int* arr, int n)&#123; for (int i = 0; i &lt; n - 1; ++i) &#123; 记录有序序列最后一个元素的下标 int end = i; 待插入的元素 int tem = arr[end + 1]; 单趟排 while (end &gt;= 0) &#123; 比插入的数大就向后移 if (tem &lt; arr[end]) &#123; arr[end + 1] = arr[end]; end--; &#125; 比插入的数小，跳出循环 else &#123; break; &#125; &#125; tem放到比插入的数小的数的后面 arr[end + 1] = tem; 代码执行到此位置有两种情况: 1.待插入元素找到应插入位置（break跳出循环到此） 2.待插入元素比当前有序序列中的所有元素都小（while循环结束后到此） &#125;&#125;————————————————版权声明：本文为CSDN博主「双鱼211」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https:blog.csdn.netweixin_50886514articledetails119045154 四、希尔排序（改进的插入排序）【间隔大的时候移动次数少，间隔小的时候移动的距离短】==缺点：不稳定== 大概：给定一个间隔分为几个组在组内排序，进行个大概的排序，再往后缩小间隔进行排序，直到间隔为1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 希尔排序【移位式】 public static void shellSort(int[] arr)&#123; int temp=arr.length2; int t=0; 临时变量 int j=0; int insertdata=0; int sub=0; int time=1; while(temp&gt;0)&#123; for (int i = temp; i &lt;arr.length; i++) &#123; insertdata=arr[i]; sub=i;j=i-temp; while(j&gt;=0&amp;&amp;insertdata&lt;=arr[j])&#123; sub=j; 保存数据 arr[j+temp]=arr[j]; j-=temp; &#125; arr[sub]=insertdata; &#125; System.out.printf(&quot;第%d次变化的的数据为:&quot;,time++); System.out.println(Arrays.toString(arr)); temp=temp2; &#125; &#125; 希尔排序【变换式】 public static void shellSort2(int[] arr)&#123; int temp=arr.length2; int t=0; 临时变量 int time=1; while(temp&gt;0)&#123; for (int i = temp; i &lt;arr.length; i++) &#123; for (int j = i-temp; j &gt;=0 ; j-=temp) &#123; if(arr[j+temp]&lt;arr[j])&#123; 直接交换数据 t=arr[j]; arr[j]=arr[j+temp]; arr[j+temp]=t; &#125; &#125; &#125; System.out.printf(&quot;第%d次变化的的数据为:&quot;,time++); System.out.println(Arrays.toString(arr)); temp=temp2; &#125; &#125;————————————————版权声明：本文为CSDN博主「莫逸雪」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https:blog.csdn.netqq_40636998articledetails103758623 使用Knuth序列来确定间隔（）减少间隔：当完成了间隔为4个排序后，再接着做间隔为1的插入排序，完成后则整个数组都会有序了。这个缩减间隔序列的数值是由knuth序列决定。 123while (h &lt;= len3) &#123; knuth序列 h = 1; h = 3*h + 1 h = h * 3 + 1; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445void shellSort(int* arr, int len) &#123;传入数组名和数组大小 int h = 1; while (h &lt;= len3) &#123; knuth序列 h = 1; h = 3*h + 1 h = h * 3 + 1; &#125; for (int gap = h; gap &gt; 0; gap = (gap - 1)3) &#123;控制间隔的大小 以下两个循环和一般插入排序一样 for (int j = gap; j &lt; len; ++j) &#123; for (int k = j; k &gt; gap - 1; k -= gap) &#123; if (arr[k] &lt; arr[k - gap]) &#123; arr[k] = arr[k] ^ arr[k - gap]; arr[k - gap] = arr[k] ^ arr[k - gap]; arr[k] = arr[k] ^ arr[k - gap]; &#125; &#125; &#125; &#125;&#125;void shellSort(int* arr, int len) &#123;传入数组名和数组大小 int h = 1; while (h &lt;= len3) &#123; knuth序列 h = 1; h = 3*h + 1 h = h * 3 + 1; &#125; for (int gap = h; gap &gt; 0; gap = (gap - 1) 3) &#123;控制间隔的大小 以下两个循环和一般插入排序一样 for (int j = gap; j &lt; len; ++j) &#123; int curValue = arr[j]; 记录当前节点的值 int lastIndex = j - gap; 记录当前节点的前一个节点的下标 while (lastIndex &gt;= 0 &amp;&amp; curValue &lt; arr[lastIndex]) &#123; 对当前节点的前面节点进行移位 arr[lastIndex + gap] = arr[lastIndex]; 符合移位的节点后移一个间隔 lastIndex -= gap; 标记前移一个间隔继续判断 &#125; arr[lastIndex + gap] = curValue; 插入最终位置 &#125; &#125;&#125;————————————————版权声明：本文为CSDN博主「子梦~」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https:blog.csdn.netqq_45678953articledetails106863217 五、归并排序递归会一直在栈中创造方法，直到内存满了之后就会错误（所以需要注意设定【basecase】） 如下图中的两个if 递归返回值之后栈会自动回收不用的方法 123456789101112131415161718192021222324252627282930313233343536public static void mergeSort(int[] arr) &#123; sort(arr, 0, arr.length - 1);&#125; public static void sort(int[] arr, int L, int R) &#123; if(L == R) &#123; return; &#125; int mid = L + ((R - L) &gt;&gt; 1); sort(arr, L, mid); sort(arr, mid + 1, R); merge(arr, L, mid, R);&#125; public static void merge(int[] arr, int L, int mid, int R) &#123; int[] temp = new int[R - L + 1]; int i = 0; int p1 = L; int p2 = mid + 1; 比较左右两部分的元素，哪个小，把那个元素填入temp中 while(p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123; temp[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++]; &#125; 上面的循环退出后，把剩余的元素依次填入到temp中 以下两个while只有一个会执行 while(p1 &lt;= mid) &#123; temp[i++] = arr[p1++]; &#125; while(p2 &lt;= R) &#123; temp[i++] = arr[p2++]; &#125; 把最终的排序的结果复制给原数组 for(i = 0; i &lt; temp.length; i++) &#123; arr[L + i] = temp[i]; &#125;&#125; 六、快速排序随机找个轴，将比他大的放右边，比他小的放左边，分为三个分区（小， 轴 ， 大），在小和大的分区中有随机找轴进行分区。一直分到只剩一个（basecase）为止 七、堆排序 八、计数排序 九、桶排序 十、基数排序","categories":[],"tags":[]},{"title":"JAVA中类、实例与Class对象","slug":"JAVA中类、实例与Class对象","date":"2021-08-25T08:48:51.000Z","updated":"2021-08-25T08:51:58.000Z","comments":true,"path":"2021/08/25/JAVA中类、实例与Class对象/","link":"","permalink":"https://wangmou-niubi.github.io/2021/08/25/JAVA%E4%B8%AD%E7%B1%BB%E3%80%81%E5%AE%9E%E4%BE%8B%E4%B8%8EClass%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"类 类是面向对象编程语言的一个重要概念，它是对一项事物的抽象概括，可以包含该事物的一些属性定义，以及操作属性的方法。面向对象编程中，我们都是以类来编码。 实例简单理解，就是new，就是对类的实例化，创建这个类对应的实际对象，类只是对事物的描述，而实例化就相当于为这个描述新开辟了一块内存，可以改变这块区域里的各种属性（成员变量），当然，也可以实例化多块区域，只是不同的对象而已。 Class注意这里C大写了，与类概念区分开，在java里，Class是一个实实在在的类，在包 java.lang 下，有这样一个Class.java文件，它跟我们自己定义的类一样，是一个实实在在的类，Class对象就是这个Class类的实例了。在Java里，所有的类的根源都是Object类，而Class也不例外，它是继承自Object的一个特殊的类，它内部可以记录类的成员、接口等信息，也就是在Java里，Class是一个用来表示类的类。（o(∩_∩)o 有点绕啊，抓住关键一点，Class是一个实实在在的类，可以为它创建实例，也就是本文后面提到的Class对象，也看叫做Class实例）。 java提供了下面几种获取到类的Class对象的方法： 1) 利用对象实例调用getClass()方法获取该对象的Class实例； 2) 使用Class类的静态方法forName(“包名+类名”)，用类的名字获取一个Class实例 3)运用 类名.class 的方式来获取Class实例； 我们知道==java世界是运行在JVM之上的==，我们编写的类代码，在经过编译器编译之后，会为每个类生成对应的.class文件，这个就是JVM可以加载执行的字节码。运行时期间，当我们需要实例化任何一个类时，JVM会首先尝试看看在内存中是否有这个类，如果有，那么会直接创建类实例；如果没有，那么就会根据类名去加载这个类，当加载一个类，或者当加载器(class loader)的defineClass()被JVM调用，便会为这个类产生一个Class对象（一个Class类的实例），用来表达这个类，该类的所有实例都共同拥有着这个Class对象，而且是唯一的。 总结 在java里，类只是信息描述的，写明了有哪些内部属性及接口，你可以理解为是定义了一套规则；而Class对象在java里被用来对类的情况进行表述的一个实例，也就是是类的实际表征，可以理解为是对规则的图表化，这样JVM才能直观的看懂，可以看做是一个模版；而类的实例化对象，就是通过模版，开辟出的一块内存进行实际的使用。 摘自https://blog.csdn.net/weixin_34289744/article/details/85729807?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162988028216780255266542%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162988028216780255266542&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-85729807.pc_search_similar&amp;utm_term=class%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB&amp;spm=1018.2226.3001.4187","categories":[],"tags":[]},{"title":"java反射","slug":"java反射","date":"2021-08-25T08:17:39.000Z","updated":"2022-01-16T11:28:28.460Z","comments":true,"path":"2021/08/25/java反射/","link":"","permalink":"https://wangmou-niubi.github.io/2021/08/25/java%E5%8F%8D%E5%B0%84/","excerpt":"","text":"一、Java反射反射是框架设计的灵魂（使用的前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件（字节码）） 1、反射的概述JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。==要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.== 以上的总结就是什么是反射==反射就是把java类中的各种成分映射成一个个的Java对象==例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。 （其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述）如图是类的正常加载过程：反射的原理在与class对象。熟悉一下加载的时候：Class对象的由来是将class文件读入内存，并为之创建一个Class对象（可以理解为类的一个模板或图表，用于）。 二、查看Class类在java中的api详解（1.7的API）如何阅读java中的api详见java基础之——String字符串处理 Class 类的实例表示正在运行的 Java 应用程序中的类和接口。也就是jvm中有N多的实例每个类都有该Class对象。（包括基本数据类型）Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的defineClass 方法自动构造的。也就是这不需要我们自己去处理创建，JVM已经帮我们创建好了。 没有公共的构造方法，方法共有64个太多了。下面用到哪个就详解哪个吧 三、反射的使用（这里使用Student类做演示）先写一个Student类。 1、获取Class对象的三种方式1.1 Object ——&gt; getClass();1.2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性1.3 通过Class类的静态方法：forName（String className）(常用) 其中1.1是因为Object类中的getClass方法、因为所有类都继承Object类。从而调用Object类来获取 123456789101112131415161718192021222324252627package fanshe;** * 获取Class对象的三种方式 * 1 Object ——&gt; getClass(); * 2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性 * 3 通过Class类的静态方法：forName（String className）(常用) * *public class Fanshe &#123; public static void main(String[] args) &#123; 第一种方式获取Class对象 Student stu1 = new Student();这一new 产生一个Student对象，一个Class对象。 Class stuClass = stu1.getClass();获取Class对象 System.out.println(stuClass.getName()); 第二种方式获取Class对象 Class stuClass2 = Student.class; System.out.println(stuClass == stuClass2);判断第一种方式获取的Class对象和第二种方式获取的是否是同一个 第三种方式获取Class对象 try &#123; Class stuClass3 = Class.forName(&quot;fanshe.Student&quot;);注意此字符串必须是真实路径，就是带包名的类路径，包名.类名 System.out.println(stuClass3 == stuClass2);判断三种方式是否获取的是同一个Class对象 &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; 注意：在运行期间，一个类，只有一个Class对象产生。三种方式常用第三种， 第一种对象都有了还要反射干什么。 第二种需要导入类的包，依赖太强，不导包就抛编译错误。 一般都用第三种，一个字符串可以传入也可写在配置文件中等多种方法。 2、通过反射获取构造方法并使用：123456789101112131415161718192021222324252627282930313233343536package fanshe; public class Student &#123; ---------------构造方法------------------- （默认的构造方法） Student(String str)&#123; System.out.println(&quot;(默认)的构造方法 s = &quot; + str); &#125; 无参构造方法 public Student()&#123; System.out.println(&quot;调用了公有、无参构造方法执行了。。。&quot;); &#125; 有一个参数的构造方法 public Student(char name)&#123; System.out.println(&quot;姓名：&quot; + name); &#125; 有多个参数的构造方法 public Student(String name ,int age)&#123; System.out.println(&quot;姓名：&quot;+name+&quot;年龄：&quot;+ age);这的执行效率有问题，以后解决。 &#125; 受保护的构造方法 protected Student(boolean n)&#123; System.out.println(&quot;受保护的构造方法 n = &quot; + n); &#125; 私有构造方法 private Student(int age)&#123; System.out.println(&quot;私有的构造方法 年龄：&quot;+ age); &#125; &#125; 测试类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package fanshe; import java.lang.reflect.Constructor; * * 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员； * * 1.获取构造方法： * 1).批量的方法： * public Constructor[] getConstructors()：所有&quot;公有的&quot;构造方法 public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有) * 2).获取单个的方法，并调用： * public Constructor getConstructor(Class... parameterTypes):获取单个的&quot;公有的&quot;构造方法： * public Constructor getDeclaredConstructor(Class... parameterTypes):获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有； * * 调用构造方法： * Constructor--&gt;newInstance(Object... initargs) *public class Constructors &#123; public static void main(String[] args) throws Exception &#123; 1.加载Class对象 Class clazz = Class.forName(&quot;fanshe.Student&quot;); 2.获取所有公有构造方法 System.out.println(&quot;**********************所有公有构造方法*********************************&quot;); Constructor[] conArray = clazz.getConstructors(); for(Constructor c : conArray)&#123; System.out.println(c); &#125; System.out.println(&quot;************所有的构造方法(包括：私有、受保护、默认、公有)***************&quot;); conArray = clazz.getDeclaredConstructors(); for(Constructor c : conArray)&#123; System.out.println(c); &#125; System.out.println(&quot;*****************获取公有、无参的构造方法*******************************&quot;); Constructor con = clazz.getConstructor(null); 1&gt;、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型 2&gt;、返回的是描述这个无参构造函数的类对象。 System.out.println(&quot;con = &quot; + con); 调用构造方法 Object obj = con.newInstance(); System.out.println(&quot;obj = &quot; + obj); Student stu = (Student)obj; System.out.println(&quot;******************获取私有构造方法，并调用*******************************&quot;); con = clazz.getDeclaredConstructor(char.class); System.out.println(con); 调用构造方法 con.setAccessible(true);暴力访问(忽略掉访问修饰符) obj = con.newInstance(&#x27;男&#x27;); &#125; &#125; 后台输出: 1234567891011121314151617**********************所有公有构造方法*********************************public fanshe.Student(java.lang.String,int)public fanshe.Student(char)public fanshe.Student()************所有的构造方法(包括：私有、受保护、默认、公有)***************private fanshe.Student(int)protected fanshe.Student(boolean)public fanshe.Student(java.lang.String,int)public fanshe.Student(char)public fanshe.Student()fanshe.Student(java.lang.String)*****************获取公有、无参的构造方法*******************************con = public fanshe.Student()调用了公有、无参构造方法执行了。。。******************获取私有构造方法，并调用*******************************public fanshe.Student(char)姓名：男 调用方法： 1.获取构造方法： 1).批量的方法：public Constructor[] getConstructors()：所有”公有的”构造方法 public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有) 2).获取单个的方法，并调用：public Constructor getConstructor(Class… parameterTypes):获取单个的”公有的”构造方法：public Constructor getDeclaredConstructor(Class… parameterTypes):获取”某个构造方法”可以是私有的，或受保护、默认、公有； 调用构造方法：Constructor–&gt;newInstance(Object… initargs) 2、 newInstance是 Constructor类的方法（管理构造函数的类）api的解释为：newInstance(Object… initargs) 使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象。并为之调用 3、获取成员变量并调用1234567891011121314151617181920package fanshe.field; public class Student &#123; public Student()&#123; &#125; **********字段************* public String name; protected int age; char sex; private String phoneNum; @Override public String toString() &#123; return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;, sex=&quot; + sex + &quot;, phoneNum=&quot; + phoneNum + &quot;]&quot;; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package fanshe.field;import java.lang.reflect.Field;* * 获取成员变量并调用： * * 1.批量的 * 1).Field[] getFields():获取所有的&quot;公有字段&quot; * 2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有； * 2.获取单个的： * 1).public Field getField(String fieldName):获取某个&quot;公有的&quot;字段； * 2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的) * * 设置字段的值： * Field --&gt; public void set(Object obj,Object value): * 参数说明： * 1.obj:要设置的字段所在的对象； * 2.value:要为字段设置的值； * *public class Fields &#123; public static void main(String[] args) throws Exception &#123; 1.获取Class对象 Class stuClass = Class.forName(&quot;fanshe.field.Student&quot;); 2.获取字段 System.out.println(&quot;************获取所有公有的字段********************&quot;); Field[] fieldArray = stuClass.getFields(); for(Field f : fieldArray)&#123; System.out.println(f); &#125; System.out.println(&quot;************获取所有的字段(包括私有、受保护、默认的)********************&quot;); fieldArray = stuClass.getDeclaredFields(); for(Field f : fieldArray)&#123; System.out.println(f); &#125; System.out.println(&quot;*************获取公有字段**并调用***********************************&quot;); Field f = stuClass.getField(&quot;name&quot;); System.out.println(f); 获取一个对象 Object obj = stuClass.getConstructor().newInstance();产生Student对象--》Student stu = new Student(); 为字段设置值 f.set(obj, &quot;刘德华&quot;);为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot; 验证 Student stu = (Student)obj; System.out.println(&quot;验证姓名：&quot; + stu.name); System.out.println(&quot;**************获取私有字段****并调用********************************&quot;); f = stuClass.getDeclaredField(&quot;phoneNum&quot;); System.out.println(f); f.setAccessible(true);暴力反射，解除私有限定 f.set(obj, &quot;18888889999&quot;); System.out.println(&quot;验证电话：&quot; + stu); &#125; &#125; 后台输出： 12345678910111213************获取所有公有的字段********************public java.lang.String fanshe.field.Student.name************获取所有的字段(包括私有、受保护、默认的)********************public java.lang.String fanshe.field.Student.nameprotected int fanshe.field.Student.agechar fanshe.field.Student.sexprivate java.lang.String fanshe.field.Student.phoneNum*************获取公有字段**并调用***********************************public java.lang.String fanshe.field.Student.name验证姓名：刘德华**************获取私有字段****并调用********************************private java.lang.String fanshe.field.Student.phoneNum验证电话：Student [name=刘德华, age=0, sex= 由此可见调用字段时：需要传递两个参数：Object obj = stuClass.getConstructor().newInstance();产生Student对象–》Student stu = new Student();为字段设置值f.set(obj, “刘德华”);为Student对象中的name属性赋值–》stu.name = “刘德华”第一个参数：要传入设置的对象，第二个参数：要传入实参 4、获取成员方法并调用student类： 123456789101112131415161718package fanshe.method; public class Student &#123; **************成员方法*************** public void show1(String s)&#123; System.out.println(&quot;调用了：公有的，String参数的show1(): s = &quot; + s); &#125; protected void show2()&#123; System.out.println(&quot;调用了：受保护的，无参的show2()&quot;); &#125; void show3()&#123; System.out.println(&quot;调用了：默认的，无参的show3()&quot;); &#125; private String show4(int age)&#123; System.out.println(&quot;调用了，私有的，并且有返回值的，int参数的show4(): age = &quot; + age); return &quot;abcd&quot;; &#125;&#125; 测试类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package fanshe.method; import java.lang.reflect.Method; * * 获取成员方法并调用： * * 1.批量的： * public Method[] getMethods():获取所有&quot;公有方法&quot;；（包含了父类的方法也包含Object类） * public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的) * 2.获取单个的： * public Method getMethod(String name,Class&lt;?&gt;... parameterTypes): * 参数： * name : 方法名； * Class ... : 形参的Class类型对象 * public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes) * * 调用方法： * Method --&gt; public Object invoke(Object obj,Object... args): * 参数说明： * obj : 要调用方法的对象； * args:调用方式时所传递的实参；): *public class MethodClass &#123; public static void main(String[] args) throws Exception &#123; 1.获取Class对象 Class stuClass = Class.forName(&quot;fanshe.method.Student&quot;); 2.获取所有公有方法 System.out.println(&quot;***************获取所有的”公有“方法*******************&quot;); stuClass.getMethods(); Method[] methodArray = stuClass.getMethods(); for(Method m : methodArray)&#123; System.out.println(m); &#125; System.out.println(&quot;***************获取所有的方法，包括私有的*******************&quot;); methodArray = stuClass.getDeclaredMethods(); for(Method m : methodArray)&#123; System.out.println(m); &#125; System.out.println(&quot;***************获取公有的show1()方法*******************&quot;); Method m = stuClass.getMethod(&quot;show1&quot;, String.class); System.out.println(m); 实例化一个Student对象 Object obj = stuClass.getConstructor().newInstance(); m.invoke(obj, &quot;刘德华&quot;); System.out.println(&quot;***************获取私有的show4()方法******************&quot;); m = stuClass.getDeclaredMethod(&quot;show4&quot;, int.class); System.out.println(m); m.setAccessible(true);解除私有限定 Object result = m.invoke(obj, 20);需要两个参数，一个是要调用的对象（获取有反射），一个是实参 System.out.println(&quot;返回值：&quot; + result); &#125;&#125; 控制台输出： 1234567891011121314151617181920212223***************获取所有的”公有“方法*******************public void fanshe.method.Student.show1(java.lang.String)public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionpublic final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionpublic final void java.lang.Object.wait() throws java.lang.InterruptedExceptionpublic boolean java.lang.Object.equals(java.lang.Object)public java.lang.String java.lang.Object.toString()public native int java.lang.Object.hashCode()public final native java.lang.Class java.lang.Object.getClass()public final native void java.lang.Object.notify()public final native void java.lang.Object.notifyAll()***************获取所有的方法，包括私有的*******************public void fanshe.method.Student.show1(java.lang.String)private java.lang.String fanshe.method.Student.show4(int)protected void fanshe.method.Student.show2()void fanshe.method.Student.show3()***************获取公有的show1()方法*******************public void fanshe.method.Student.show1(java.lang.String)调用了：公有的，String参数的show1(): s = 刘德华***************获取私有的show4()方法******************private java.lang.String fanshe.method.Student.show4(int)调用了，私有的，并且有返回值的，int参数的show4(): age = 20返回值：abcd 由此可见：m = stuClass.getDeclaredMethod(“show4”, int.class);调用制定方法（所有包括私有的），需要传入两个参数，第一个是调用的方法名称，第二个是方法的形参类型，切记是类型。 System.out.println(m); m.setAccessible(true);解除私有限定 Object result = m.invoke(obj, 20);需要两个参数，一个是要调用的对象（获取有反射），一个是实参 System.out.println(“返回值：” + result); 其实这里的成员方法：在模型中有属性一词，就是那些setter（）方法和getter()方法。还有字段组成，这些内容在内省中详解 5、反射main方法 student类： 123456789package fanshe.main; public class Student &#123; public static void main(String[] args) &#123; System.out.println(&quot;main方法执行了。。。&quot;); &#125;&#125; 测试类： 123456789101112131415161718192021222324252627282930package fanshe.main; import java.lang.reflect.Method; ** * 获取Student类的main方法、不要与当前的main方法搞混了 *public class Main &#123; public static void main(String[] args) &#123; try &#123; 1、获取Student对象的字节码 Class clazz = Class.forName(&quot;fanshe.main.Student&quot;); 2、获取main方法 Method methodMain = clazz.getMethod(&quot;main&quot;, String[].class);第一个参数：方法名称，第二个参数：方法形参的类型， 3、调用main方法 methodMain.invoke(null, new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;); 第一个参数，对象类型，因为方法是static静态的，所以为null可以，第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数 这里拆的时候将 new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125; 拆成3个对象。。。所以需要将它强转。 methodMain.invoke(null, (Object)new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;);方式一 methodMain.invoke(null, new Object[]&#123;new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;&#125;);方式二 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 控制台输出： main方法执行了。。。 6、反射方法的其它使用之—通过反射运行配置文件内容Student类： 123456public class Student &#123; public void show()&#123; System.out.println(&quot;is show()&quot;); &#125;&#125; 配置文件以txt文件为例子（pro.txt）： 12className = cn.fanshe.StudentmethodName = show 测试类： 123456789101112131415161718192021222324252627282930import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.lang.reflect.Method;import java.util.Properties; * * 我们利用反射和配置文件，可以使：应用程序更新时，对源码无需进行任何修改 * 我们只需要将新类发送给客户端，并修改配置文件即可 *public class Demo &#123; public static void main(String[] args) throws Exception &#123; 通过反射获取Class对象 Class stuClass = Class.forName(getValue(&quot;className&quot;));&quot;cn.fanshe.Student&quot; 2获取show()方法 Method m = stuClass.getMethod(getValue(&quot;methodName&quot;));show 3.调用show()方法 m.invoke(stuClass.getConstructor().newInstance()); &#125; 此方法接收一个key，在配置文件中获取相应的value public static String getValue(String key) throws IOException&#123; Properties pro = new Properties();获取配置文件的对象 FileReader in = new FileReader(&quot;pro.txt&quot;);获取输入流 pro.load(in);将流加载到配置文件对象中 in.close(); return pro.getProperty(key);返回根据key获取的value值 &#125;&#125; 控制台输出：is show() 需求：当我们升级这个系统时，不要Student类，而需要新写一个Student2的类时，这时只需要更改pro.txt的文件内容就可以了。代码就一点不用改动 要替换的student2类： 12345public class Student2 &#123; public void show2()&#123; System.out.println(&quot;is show2()&quot;); &#125;&#125; 配置文件更改为： 12className = cn.fanshe.Student2methodName = show2 控制台输出： is show2(); 7、反射方法的其它使用之—通过反射越过泛型检查泛型用在编译期，编译过后泛型擦除（消失掉）。所以是可以通过反射越过泛型检查的 测试类： 12345678910111213141516171819202122232425262728import java.lang.reflect.Method;import java.util.ArrayList; * * 通过反射越过泛型检查 * * 例如：有一个String泛型的集合，怎样能向这个集合中添加一个Integer类型的值？ *public class Demo &#123; public static void main(String[] args) throws Exception&#123; ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add(&quot;aaa&quot;); strList.add(&quot;bbb&quot;); strList.add(100); 获取ArrayList的Class对象，反向的调用add()方法，添加数据 Class listClass = strList.getClass(); 得到 strList 对象的字节码 对象 获取add()方法 Method m = listClass.getMethod(&quot;add&quot;, Object.class); 调用add()方法 m.invoke(strList, 100); 遍历集合 for(Object obj : strList)&#123; System.out.println(obj); &#125; &#125;&#125; 控制台输出： aaabbb100 ————————————————版权声明：本文为CSDN博主「敬业的小码哥」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https:blog.csdn.netsinat_38259539articledetails71799078","categories":[],"tags":[]},{"title":"IOC控制反转","slug":"IOC控制反转","date":"2021-08-25T08:04:04.000Z","updated":"2022-01-16T11:28:14.210Z","comments":true,"path":"2021/08/25/IOC控制反转/","link":"","permalink":"https://wangmou-niubi.github.io/2021/08/25/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/","excerpt":"","text":"IoC概述什么是IoC？IoC即Inversion of Control，翻译过来就是控制反转。啥是控制反转啊？控制反转指的就是将对象的创建权反转给（交给）了Spring，其作用是实现了程序的解耦合。也可这样解释：获取对象的方式变了，对象创建的控制权不是”使用者”，而是”框架”或者”容器”。用更通俗的话来说，IoC就是指对象的创建，并不是在代码中用new操作new出来的，而是通过Spring进行配置创建的。 Spring的IoC的底层实现原理这里先给出结论：Spring的IoC的底层实现原理是工厂设计模式+反射+XML配置文件。 就拿持久层（也即dao层，data access object，数据访问对象）的开发来说，官方推荐做法是先创建一个接口，然后再创建接口对应的实现类。所以，这里，我会以dao层的开发为例来证明Spring的IoC的底层实现原理就是工厂设计模式+反射+XML配置文件。首先，创建一个Userdao接口。 123public interface UserDao &#123; public void add();&#125; 然后，再创建Userdao接口的一个实现类（UserDaoImpl.java）。 12345public class UserDaoImpl implements UserDao &#123; public void add() &#123; balabala...... &#125;&#125; 接着，我们在service层中调用dao层，核心代码如下： 123 接口 实例变量 = new 实现类UserDao dao = new UserDaoImpl();dao.add(); 这时我们便可发现一个缺点：service层和dao层耦合度太高了，即接口和实现类有耦合（它俩之间的联系过于紧密），一旦切换底层实现类，那么就需要修改源代码，这真的不是一个好的程序设计，好的程序设计应当满足OCP原则（也即开闭原则），即在尽量不修改程序源代码的基础上对程序进行扩展。说到这里，我就不得不稍微讲一下面向对象设计的七大原则了，它不必强记，重在理解 出现的这个问题该如何解决呢？解决方法是使用工厂设计模式进行解耦合操作。所以，我们需要创建一个工厂类，在工厂类中提供一个方法，返回实现类的对象。 123456public class BeanFactory &#123; 提供返回实现类对象的方法 public static UserDao getUserDao() &#123; return new UserDaoImpl(); &#125;&#125; 这样，在service层中调用dao层的核心代码就变为了下面的样子。 12UserDao dao = BeanFactory.getUserDao();dao.add(); 如若这样做，会发现又产生了一个缺点：现在接口和实现类之间是没有耦合了，但是service层和工厂类耦合了。如果真正想实现程序之间的解耦合，那么就需要使用到工厂设计模式+反射+XML配置文件了。所以，我们这里提供一个XML配置文件，并且该配置文件中有如下配置信息。 1&lt;bean id=&quot;userDao&quot; class=&quot;com.meimeixia.dao.impl.UserDaoImpl&quot; &gt; 然后再来创建一个工厂类，在工厂类中提供一个返回实现类对象的方法，但并不是直接new实现类，而是使用SAX解析配置文件，根据标签bean中的id属性值得到对应的class属性值，使用反射创建实现类对象。 12345678910 public static Object getBean(String id) &#123; 1.使用SAX解析得到配置文件内容 直接根据id值userDao得到class属性值 String classvalue = &quot;class属性值&quot;; 2.使用反射得到对象 Class clazz = Class.forName(classvalue); UserDaoImpl userDaoImpl = (UserDaoImpl)clazz.newInstance(); return userDaoImpl; &#125;&#125; 以上就是Spring的IoC的底层实现原理。 ————————————————版权声明：本文为CSDN博主「李阿昀」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https:blog.csdn.netyerenyuan_pkuarticledetails69663685 一下为其他截图帮助理解","categories":[],"tags":[]},{"title":"声明式事务","slug":"声明式事务","date":"2021-08-25T07:58:20.000Z","updated":"2021-08-25T07:59:46.000Z","comments":true,"path":"2021/08/25/声明式事务/","link":"","permalink":"https://wangmou-niubi.github.io/2021/08/25/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"2.声明式事务摘自https://blog.csdn.net/qq_40392686/article/details/82990406?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162987788116780261943474%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162987788116780261943474&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-82990406.pc_search_similar&amp;utm_term=%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1&amp;spm=1018.2226.3001.4187 编程式事务：指的是由程序员编写事务控制代码，包含事务的提交与回滚等。声明式事务：事务控制代码已经由Spring写好，程序员只需要声明出哪些方法需要进行事务控制和如何进行事务控制。 声明式事务都是针对ServiceImpl类下的方法的事务管理器是基于通知（advice）的 Service接口 1234public interface UsersService &#123; public int insert(Users users); public int insUsers(Users users);&#125; ServiceImpl类 1234567891011public class UsersServiceImpl implements UsersService&#123; @Override public int insert(Users users) &#123; return 0; &#125; @Override public int insUsers(Users users) &#123; return 0; &#125; &#125; 配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot; &gt; &lt;!-- 数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ssm&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置声明式事务 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 那些方法需要有事务控制 --&gt; &lt;!-- 以ins开头的方法 --&gt; &lt;tx:method name=&quot;ins*&quot;/&gt; &lt;!-- 以del开头的方法 --&gt; &lt;tx:method name=&quot;del*&quot;/&gt; &lt;tx:method name=&quot;upd*&quot;/&gt; &lt;tx:method name=&quot;*&quot; read-only=&quot;true&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(* com.lee.service.impl.*.*(..))&quot; id=&quot;mypoint&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;mypoint&quot;/&gt; &lt;/aop:config&gt; 声明式事务中属性解释1 name=”” 哪些方法需要有事务控制，支持通配符2 readonly=“boolean” 是否是只读事务如果为true，告诉数据库此事务为只读事务，数据库优化，会对性能有一定提升，所以只要是查询方法，建议使用；如果为false，事务需要提交事务，当增删改的时候使用。3 propagation 控制事务传播行为当一个具有事务控制的方法被另一个有事务控制的方法调用后，需要如何管理事务（新建事务？在事务中执行？把事务挂起？报异常？）3.1 REQUIRED：（默认值）如果当前有事务，就在事务中进行，如果当前没有事务，就新建一个事务3.2 SUPPORTS： 如果当前有事务，就在事务中执行，如果当前没有事务，就在非事务状态下执行3.3 MANDATORY： 必须在事务内部执行，如果当前有事务，就在事务中执行，如果没有事务，报错3.4 REQUIRES_NEW： 必须在事务中执行，如果当前没有事务，就新建事务，如果当前有事务，就将当前的事务挂起3.5 NOT_SUPPORTED： 必须在非事务下执行，如果当前没有事务，正常执行，如果当前有事务，把事务挂起3.6 NEVER：必须在非事务状态下执行，如果当前没有事务，正常执行，如果有事务，报错。3.7 NESTED：必须在事务状态下执行，如果有没有事务，新建事务，如果当前有事务，创建一个嵌套事务。","categories":[],"tags":[]},{"title":"面向切面编程AOP","slug":"面向切面编程AOP","date":"2021-08-25T07:32:59.000Z","updated":"2022-01-16T11:31:15.780Z","comments":true,"path":"2021/08/25/面向切面编程AOP/","link":"","permalink":"https://wangmou-niubi.github.io/2021/08/25/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8BAOP/","excerpt":"","text":"以下内容摘自：https:blog.csdn.netqq_42539533articledetails90551738?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162987660316780269849659%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162987660316780269849659&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduend~default-2-90551738.pc_search_similar&amp;utm_term=AOP%E7%BC%96%E7%A8%8B&amp;spm=1018.2226.3001.4187 并结合自己的理解 一、面向切面编程AOPAOP介绍AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming）的完善或者二次利用，在面向对象的代码执行过程中动态嵌入其他代码。 面向切面编程是面向对象中的一种方式而已。在代码执行过程中，动态嵌入其他代码，叫做面向切面编程。常见的使用场景： 1.日志 2.事物 3.数据库操作 面向切面编程，就是将交叉业务逻辑封装成切面，利用AOP的功能将切面织入到主业务逻辑中。所谓交叉业务逻辑是指，通用的，与主业务逻辑无关的代码，如安全检查，事物，日志等。若不使用AOP，则会出现代码纠缠，即交叉业务逻辑与主业务逻辑混合在一起。这样，会使业务逻辑变得混杂不清。举个例子：银行系统取款会有一个流程查询也会有一个流程 这两者，都有一个相同的验证用户的流程 这个时候 AOP 就可以来帮我们简化代码了，首先，写代码的时候可以不写这个验证用户的步骤，即完全不考虑验证用户，写完之后，在另外一个地方，写好验证用户的代码，然后告诉 Spring 你要把这一段代码加到哪几个地方，Spring就会帮你加过去，这里还只是两个地方，如果有多个控制流，这样写代码会大大节约时间。 而且 AOP 不会把代码加到源文件里，但是它会正确的影响最终的机器代码。 上面那个 验证用户 的方框，我们可以把它当成一块板子，在这块板子上插入一些控制流程，这块板子就可以当成是 AOP 中的一个切面。所以 AOP 的本质是在一系列的纵向的控制流程中，把那些相同的子流程提取成一个横向的面，把纵向流程画成一条直线，而 AOP 相当于把相同的地方连起来了 再来一幅图理解一下： 这个验证用户的子流程 就成了一条直线，也可以理解成一个切面，这里只插了三个流程，如果其他流程也需要这个子流程，也可以插到其他地方去。 AOP术语 AOP的实现方式 以上为摘抄内容 二、自己的理解","categories":[],"tags":[]},{"title":"Spring","slug":"Spring","date":"2021-08-22T01:59:50.000Z","updated":"2022-01-16T11:28:51.430Z","comments":true,"path":"2021/08/22/Spring/","link":"","permalink":"https://wangmou-niubi.github.io/2021/08/22/Spring/","excerpt":"","text":"IOC底层原理：（1）xml解析 、工厂模式 、 反射 1.BeanFactory1234//XmlBeanFactory是典型的BeanFactory。 BeanFactory factory = new XmlBeanFactory(&quot;XXX.xml&quot;); //获取一个叫做mdzz的bean。在这个时候进行实例化。 factory.getBean(&quot;mdzz&quot;); 重点：当我们使用BeanFactory去获取Bean的时候，我们只是实例化了该容器，而该容器中的bean并没有被实例化。当我们getBean的时候，才会实时实例化该bean对象。 2.ApplicationContext(空间换时间)12//当我们实例化XXX.xml的时候，该文件中配置的bean都会被实例化。（该bean scope是singleton）ApplicationContext appContext = new ClassPathXmlApplicationContext(&quot;XXX.xml&quot;); 重点：当我们使用ApplicationContext去获取bean的时候，在加载XXX.xml的时候，会创建所有的配置bean。 工厂模式 spring 容器类似于婚介，无论你想不想要，都已经注册在里面了，你要用的时候 直接get就行 在配置文件加在的时候，容器中管理的对象就已经初始化了 5、Spring配置5.1 别名（alias）1&lt;alias name=&quot;user&quot; alias=&quot;asdfg&quot;&gt; 5.2 Bean的配置id：bean的唯一标识符，也就相当于对象名 class：bean对象所对应的全限定名： 包名+ 类型名 name: 也是别名，而且更加高级，可以同时取多个别名（逗号，空格 ，分号都可以将name区分） 5.3 import 6、依赖注入6.1 构造器注入前面说过了 6.2 set方式注入【重点】 ![(/img_17.png) !(/../../../../AppData/Roaming/Typora/typora-user-images/image-20210822155713898.png) 6.3 拓展方式注入可以使用c命名空间和p命名空间进行注入 官方解释 注意：c命名空间和p命名空间不能直接使用，需要导入xml约束 6.4 Bean的作用域 1.单例模式（Spring默认机制） 2.原型模式 每次get都会产生一个新对象 3.其余的 request 、 session 、 application只在web中用到 request ：创建完就失效 session：一直在session里活着 application：全局活着 7.Bean的自动装配 7.4、使用注解实现自动装配 一、Spring1.优点 2.声明式事务摘自https://blog.csdn.net/qq_40392686/article/details/82990406?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162987788116780261943474%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162987788116780261943474&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-82990406.pc_search_similar&amp;utm_term=%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1&amp;spm=1018.2226.3001.4187 编程式事务：指的是由程序员编写事务控制代码，包含事务的提交与回滚等。声明式事务：事务控制代码已经由Spring写好，程序员只需要声明出哪些方法需要进行事务控制和如何进行事务控制。 声明式事务都是针对ServiceImpl类下的方法的事务管理器是基于通知（advice）的 Service接口 1234public interface UsersService &#123; public int insert(Users users); public int insUsers(Users users);&#125; ServiceImpl类 1234567891011public class UsersServiceImpl implements UsersService&#123; @Override public int insert(Users users) &#123; return 0; &#125; @Override public int insUsers(Users users) &#123; return 0; &#125; &#125; 配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot; &gt; &lt;!-- 数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ssm&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置声明式事务 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 那些方法需要有事务控制 --&gt; &lt;!-- 以ins开头的方法 --&gt; &lt;tx:method name=&quot;ins*&quot;/&gt; &lt;!-- 以del开头的方法 --&gt; &lt;tx:method name=&quot;del*&quot;/&gt; &lt;tx:method name=&quot;upd*&quot;/&gt; &lt;tx:method name=&quot;*&quot; read-only=&quot;true&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(* com.lee.service.impl.*.*(..))&quot; id=&quot;mypoint&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;mypoint&quot;/&gt; &lt;/aop:config&gt; 声明式事务中属性解释1 name=”” 哪些方法需要有事务控制，支持通配符2 readonly=“boolean” 是否是只读事务如果为true，告诉数据库此事务为只读事务，数据库优化，会对性能有一定提升，所以只要是查询方法，建议使用；如果为false，事务需要提交事务，当增删改的时候使用。3 propagation 控制事务传播行为当一个具有事务控制的方法被另一个有事务控制的方法调用后，需要如何管理事务（新建事务？在事务中执行？把事务挂起？报异常？）3.1 REQUIRED：（默认值）如果当前有事务，就在事务中进行，如果当前没有事务，就新建一个事务3.2 SUPPORTS： 如果当前有事务，就在事务中执行，如果当前没有事务，就在非事务状态下执行3.3 MANDATORY： 必须在事务内部执行，如果当前有事务，就在事务中执行，如果没有事务，报错3.4 REQUIRES_NEW： 必须在事务中执行，如果当前没有事务，就新建事务，如果当前有事务，就将当前的事务挂起3.5 NOT_SUPPORTED： 必须在非事务下执行，如果当前没有事务，正常执行，如果当前有事务，把事务挂起3.6 NEVER：必须在非事务状态下执行，如果当前没有事务，正常执行，如果有事务，报错。3.7 NESTED：必须在事务状态下执行，如果有没有事务，新建事务，如果当前有事务，创建一个嵌套事务。————————————————版权声明：本文为CSDN博主「后知后觉后海」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_40392686/article/details/82990406","categories":[],"tags":[]},{"title":"Springboot","slug":"Springboot","date":"2021-08-22T01:05:17.000Z","updated":"2021-08-25T07:50:02.000Z","comments":true,"path":"2021/08/22/Springboot/","link":"","permalink":"https://wangmou-niubi.github.io/2021/08/22/Springboot/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Vue脚手架","slug":"Vue脚手架","date":"2021-08-12T12:37:57.000Z","updated":"2021-08-12T12:37:58.000Z","comments":true,"path":"2021/08/12/Vue脚手架/","link":"","permalink":"https://wangmou-niubi.github.io/2021/08/12/Vue%E8%84%9A%E6%89%8B%E6%9E%B6/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"WebPack","slug":"WebPack","date":"2021-08-12T09:04:48.000Z","updated":"2021-08-12T12:22:20.000Z","comments":true,"path":"2021/08/12/WebPack/","link":"","permalink":"https://wangmou-niubi.github.io/2021/08/12/WebPack/","excerpt":"","text":"一、WebPack官方解释： ​ 本质上，webpack 是一个用于现代 JavaScript 应用程序的 静态 模块打包 工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 bundle。 ps.（WebPack依赖Node环境,而Node环境为了正常执行代码又包含各种依赖的包所以需要npm（node包管理）工具） 对于打包的理解： 1.前端模块化 2.与grunt/gulp的对比","categories":[],"tags":[]},{"title":"Vue组件","slug":"Vue组件","date":"2021-08-12T01:19:40.000Z","updated":"2021-08-25T11:44:42.000Z","comments":true,"path":"2021/08/12/Vue组件/","link":"","permalink":"https://wangmou-niubi.github.io/2021/08/12/Vue%E7%BB%84%E4%BB%B6/","excerpt":"","text":"一、Vue组件1.认识组件化 2.父组件与子组件之间的数据传输以及扩展父传子用prop 子传父用事件$event 2.1组件开发三要素prop,自定义事件,slot是组成组件的三个重要因素。 prop用于定义组件的属性。 自定义事件用于触发组件的事件。 slot用于组件功能的扩展。 通过合理的使用这三个API，可以更好地帮助我们开发组件。 2.2关于 slot:slot 我们定义的组件通常会被用到各个地方，但是并不一定能够满足所有的使用场景，有时候我们需要进行一些功能的扩展。这时候就需要用到slot了。一句话描述slot:就是用来在组件中插入新的内容。比如我们刚刚定义的Child组件，需要插入一段话。那么这时候就需要用到slot了。Child.vue中使用slot 12345678&lt;template&gt; &lt;div class&#x3D;&quot;container&quot;&gt; 姓名：&#123;&#123;name&#125;&#125; 年龄：&#123;&#123;age&#125;&#125; &lt;button @click &#x3D;&quot;$emit(&#39;onClick&#39;,&#39;自定义事件&#39;)&quot; :class &#x3D; &quot;type&quot;&gt;点击&lt;&#x2F;button&gt; &lt;slot&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; Parent.vue中扩展功能。插入一段话： 1234567&lt;template&gt; &lt;div class&#x3D;&quot;container&quot;&gt; &lt;Child @onClick &#x3D; &#39;handleClick&#39; :age &#x3D; age :type &#x3D; type&gt; &lt;div&gt;这是通过slot插入的一段话&lt;&#x2F;div&gt; &lt;&#x2F;Child&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 如上所示：在Child.vue中使用了slot，在Parent.vue中使用CHild时，插入了一段话。实现了功能的扩展。当然如果需要扩展更多的功能可以使用具名插槽，这里就不具体介绍了。 摘自：https://www.cnblogs.com/yinhaiying/p/10985476.html 二.前端模块化为什么有模块化？ ​ 原始js功能越来越复杂后，会存在不同文件中命名冲突而导致引用出错，以及方法的难以封装的问题等。 1.核心：导入（import）导出（export） 用export default 导出后导入时可以自己命名 例如： export default address (只能有一个)【不会被命名限制】","categories":[],"tags":[]},{"title":"Vue笔记","slug":"Vue笔记","date":"2021-08-10T07:28:40.000Z","updated":"2021-08-25T11:49:20.000Z","comments":true,"path":"2021/08/10/Vue笔记/","link":"","permalink":"https://wangmou-niubi.github.io/2021/08/10/Vue%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一、Vue.js是什么官方解释：Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 我自己对渐进式的理解 渐进式在我看来就是： 不用全部使用vue来完成业务，可以逐步去选择。（将模块挂载到vue即可） 业务模块的渐进式的调用，也就是组件化，组件在不需要的时候不加载，当业务需要时再加载。 Vue的体验部分实例1：（基本的显示信息的方法以及 v-for 遍历） 1234567891011121314151617181920212223242526272829&lt;div id=&quot;map&quot;&gt;case1:王某 &#123;&#123;message&#125;&#125;&lt;br&gt;case2:&#123;&#123;movies&#125;&#125; &lt;ul&gt;&lt;!--v-for遍历--&gt; &lt;li v-for=&quot;item in movies&quot;&gt;case3: &#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;!--此处自动解析特殊语法--&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 编程范式:声明式编程（会有proxy[代理]） // 只需声明显示什么东西 const app = new Vue( //此处为options属性 &#123; el: &#x27;#map&#x27;,//用于挂载要管理的元素 data: &#123;//定义数据 message: &quot;好得很！&quot;, movies: [&#x27;王某牛逼？&#x27;,&#x27;王某非常牛逼！&#x27;] &#125; &#125; ) // 原生js（ 编程范式：命令式编程） // 1.创建div元素,设置id属性 // 2.定义一个变量message // 3.将message变量在div元素中显示&lt;/script&gt; 123456789101112131415161718192021222324252627282930&lt;div id=&quot;add&quot;&gt; &lt;h2&gt;当前计数： &#123;&#123;counter&#125;&#125;&lt;/h2&gt; &lt;!-- click:点击事件--&gt; &lt;!-- @click为v-on:click 的语法糖（简写）--&gt; &lt;button @click=&quot;add&quot;&gt;+&lt;/button&gt; &lt;button v-on:click=&quot;sub&quot;&gt;-&lt;/button&gt;&lt;!-- 不采取这种方法 不方便管理和阅读--&gt;&lt;!-- &lt;h2&gt;当前计数： &#123;&#123;counter&#125;&#125;&lt;/h2&gt;--&gt;&lt;!-- &lt;button v-on:click=&quot;counter++&quot;&gt;+&lt;/button&gt;--&gt;&lt;!-- &lt;button v-on:click=&quot;counter--&quot;&gt;-&lt;/button&gt;--&gt;&lt;/div&gt;&lt;!--此处自动解析特殊语法--&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const add = new Vue(&#123; el: &#x27;#add&#x27;, data: &#123; counter: 0 &#125;, methods:&#123; add: function () &#123; this.counter++; &#125;, sub: function () &#123; this.counter--; &#125; &#125; &#125;)&lt;/script&gt; Vue中的MVVMViewModel是Vue.js的核心，它是一个Vue实例。Vue实例是作用于某一个HTML元素上的，这个元素可以是HTML的body元素，也可以是指定了id的某个元素。 当创建了ViewModel后，双向绑定是如何达成的呢？ 首先，我们将上图中的DOM Listeners和Data Bindings看作两个工具，它们是实现双向绑定的关键。从View侧看，ViewModel中的DOM Listeners工具会帮我们监测页面上DOM元素的变化，如果有变化，则更改Model中的数据；从Model侧看，当我们更新Model中的数据时，Data Bindings工具会帮我们更新页面中的DOM元素。 &lt;body&gt; &lt;!--这是我们的View--&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 这是我们的Model var exampleData = &#123; message: &#39;Hello World!&#39; &#125; // 创建一个 Vue 实例或 &quot;ViewModel&quot; // 它连接 View 与 Model new Vue(&#123; el: &#39;#app&#39;, data: exampleData &#125;) &lt;/script&gt; 原文地址：https://blog.csdn.net/youlingxx/article/details/79361979?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162864479416780261910512%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162864479416780261910512&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-79361979.pc_search_download_positive&amp;utm_term=VueMVVM&amp;spm=1018.2226.3001.4187 创建Vue时的options属性options的五类属性： 数据：data、 props、 propsData、 computed、methods、 Watch DOM: el、 template、 render、 renderError 生命周期钩子: beforeCreate、 created、beforeMount、 mounted、 beforeUpdate、 updated、activated、 deactivated、 beforeDestroy、 destroyed、errorCaptured 资源: directives、 filters、 components 组合: parent, mixins、 extends、 provide、 inject vue的功能 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。（响应式：当页面更改，例如放大缩小后页面会根据相应情况进行修改、当数据改变内容也跟随改变）【可以直接在页网页控制台进行修改数据】 较为常用的Vue指令 v-once只加载一次 v-text元素的InnerText属性,必须是双标签 v-pre载入原生语法 v-html元素的innerHTML v-if判断是否插入这个元素 如果为false不会存在在dom中【注意和v-show区分】 适用于一次切换 v-else-ifv-else v-show隐藏元素 如果确定要隐藏, 会给元素的style加上display:none 适用于多次（频繁）切换 v-cloak(斗篷)[不怎么用]在未加载成功之前不显示（display：none），加载成功后移除 v-on ​ 我们可以用 v-on 指令添加一个事件监听器（click） .stop 修饰符 调用event.stopPropagation（阻止冒泡，button与div都有点击时被同时识别为点击） .prevent修饰符 调用event.preventDefault（阻止自动提交） @keyup 监听所有键帽的松开(‘W,D’)【@为 语法糖】 @keyup.enter 监听回车的松开 @click.native 监听组建根元素的原生事件 @click.once 只调用一次 v-for v-for 指令可以绑定数组/对象的数据来渲染一个项目列表 数组： 格式为：item in items (item,index) in items 中index为下标（索引值） 对象(inf)： 格式： item in inf 会将属性的值遍历 格式：（value,key）in inf /(value,key,index) in inf 打印出来就是这种格式- 如果要实现中间插入，需要为遍历元素绑定能够一一对应key（不用index，用item）【:key ‘item’】，不然会将之后的都后移，会影响性能 v-model(应用于textarea以及input等) v-model` 指令，它能轻松实现表单输入和应用状态之间的双向绑定 v-bind（语法糖直接加 ‘ : ’ 符号）v-bind 指令，对style,class等对象或者数组进行动态绑定 （具体实例参见vue官网,） 计算属性computed（函数转属性）对于文字的连接（ + ‘ ‘ + ） 对于数字的计算 getter和setter修饰符 .stop 修饰符 调用event.stopPropagation（阻止冒泡，button与div都有点击时被同时识别为点击） .prevent修饰符 调用event.preventDefault（阻止自动提交） @keyup 监听所有键帽的松开(‘W,D’)【@为 语法糖】 @keyup.enter 监听回车的松开 @click.native 监听组建根元素的原生事件 @click.once 只调用一次 其他注意事项 mustache：{{ }}；胡须语法 下图中obj中的counter也会因为代理（proxy）而被下面的counter++所改变 vue 在渲染dom之前会生成虚拟dom，出于性能考虑，会尽可能地去复用已经存在的元素，而不是重新创建新的元素。（后续似乎已解决）会造成，input框修改后，内容依然存在的问题，也可以通过加不同的 key： 来保证唯一性来解决问题 表单提交是设置相同的name，则只能选择一个（例如 复选框 男女 name:sex）【互斥】 select 使用 multiple实现多选 ES6补充 变量作用域：变量在什么范围是可用的 12345678&lt;script&gt; &#123; var id = 12; console.log(id) &#125; console.log(id) //两者所打印出来的都是12&lt;/script&gt; if块级，for块级 函数闭包能够保存变量（函数有自己的作用域） es5之前if for 都没有块级作用域 const不可以改变指向但是可用改变属性 123456const obj&#123; name:&quot;nihao&quot;, age:12&#125;//name 和 age 可用修改//obj不行 属性增强写法 123456789101112const age = 2;const name =&quot;wang&quot;;const obj = &#123; age, name&#125;const obj2 = &#123; age: age, name : name&#125; 两种情况打印出来一样，上面更加简洁 函数增强写法 12345678const obj = &#123; run : founction ()&#123;&#125;&#125;const obj = &#123; run()&#123;&#125; 二者一样下面个更加简洁 当事件定义时，写函数时省略了小括号，但是方法本身是有参数的，这个时候vue会默认将浏览器生成的event事件对象作为参数传入到方法 12345678910111213&lt;button @click=&quot;btn2click&quot;&gt;&lt;/button&gt;...................btn2click(abc)&#123;........&#125; 可以通过$event表示事件 并不是所有的改变数组数据的方法都会响应式 例如：直接用等号（=）赋值不会响应【不能通过索引值来修改】 this.letter[0] = ‘ ‘; X 12// 要修改的对象，索引值 要修改的内容Vue.set(this.lettter,0,&quot; &quot;) 以上方法可以响应 下列两种for方法分别得到对象数组的索引值和对象。（ for-in 中 i 为索引值 ， for-of 中 item 为 对象） 为增强可读性可以使用流式编程加上lamda表达式 12// 过滤 对信息进行乘2操作 对旧数据实现类似递归的操作let total = nums.filter(n=&gt; n &lt; 100).map(n =&gt; n*2).reduce((pre,n) =&gt; pre+n)) 组件的key属性","categories":[],"tags":[]},{"title":"dd","slug":"2021-3-7-5：08-我终于克服种种困难，成功发表了我的第一篇博文，虽然不知道是否有用，但是能看见自己一步一步建立的网站还是感觉自己很骄傲，希望我的博文在日后能得到别人的赏识。","date":"2021-03-06T21:11:14.000Z","updated":"2022-01-16T10:33:35.493Z","comments":true,"path":"2021/03/07/2021-3-7-5：08-我终于克服种种困难，成功发表了我的第一篇博文，虽然不知道是否有用，但是能看见自己一步一步建立的网站还是感觉自己很骄傲，希望我的博文在日后能得到别人的赏识。/","link":"","permalink":"https://wangmou-niubi.github.io/2021/03/07/2021-3-7-5%EF%BC%9A08-%E6%88%91%E7%BB%88%E4%BA%8E%E5%85%8B%E6%9C%8D%E7%A7%8D%E7%A7%8D%E5%9B%B0%E9%9A%BE%EF%BC%8C%E6%88%90%E5%8A%9F%E5%8F%91%E8%A1%A8%E4%BA%86%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87%EF%BC%8C%E8%99%BD%E7%84%B6%E4%B8%8D%E7%9F%A5%E9%81%93%E6%98%AF%E5%90%A6%E6%9C%89%E7%94%A8%EF%BC%8C%E4%BD%86%E6%98%AF%E8%83%BD%E7%9C%8B%E8%A7%81%E8%87%AA%E5%B7%B1%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%BB%BA%E7%AB%8B%E7%9A%84%E7%BD%91%E7%AB%99%E8%BF%98%E6%98%AF%E6%84%9F%E8%A7%89%E8%87%AA%E5%B7%B1%E5%BE%88%E9%AA%84%E5%82%B2%EF%BC%8C%E5%B8%8C%E6%9C%9B%E6%88%91%E7%9A%84%E5%8D%9A%E6%96%87%E5%9C%A8%E6%97%A5%E5%90%8E%E8%83%BD%E5%BE%97%E5%88%B0%E5%88%AB%E4%BA%BA%E7%9A%84%E8%B5%8F%E8%AF%86%E3%80%82/","excerpt":"","text":"我终于克服种种困难，成功发表了我的第一篇博文，虽然不知道是否有用，但是能看见自己一步一步建立的网站还是感觉自己很骄傲，希望我的博文在日后能得到别人的赏识。","categories":[],"tags":[]},{"title":"我的第一篇博文","slug":"我的第一篇博文","date":"2021-03-06T21:07:35.000Z","updated":"2021-03-06T21:07:36.000Z","comments":true,"path":"2021/03/07/我的第一篇博文/","link":"","permalink":"https://wangmou-niubi.github.io/2021/03/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[],"tags":[]}